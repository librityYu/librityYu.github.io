<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta property="og:type" content="website">
<meta property="og:title" content="Liberty&#39;s Blog">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Liberty&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Liberty">
<meta name="twitter:card" content="summary"><title>Liberty's Blog</title><link ref="canonical" href="http://example.com/page/3/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: true,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/日记/"><span class="header-nav-menu-item__icon"><i class="fas fa-book"></i></span><span class="header-nav-menu-item__text">日记</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">Liberty's Blog</div><div class="header-banner-info__subtitle"></div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/11/03/Ipc/">Ipc</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-11-03</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2023-04-26</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>IPC:</p>
<p>进行进程间的通信，对象数据是需要进行序列化的。序列化方法有：</p>
<ol>
<li>Serializable接口（java提供的）：使用简单，但是序列化的开销大，序列化和反序列化需要大量的I/O操作。</li>
<li>Parcelable接口（android提供的）：使用麻烦点，但是效率高。</li>
</ol>

        <h1 id="Binder">
          <a href="#Binder" class="heading-link"><i class="fas fa-link"></i></a><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h1>
      <p>Binder就是一个类，一个实现接口IBinder接口的类。Binder是ServiceManager连接各种Manager(ActivityManager,WindowManager)和相应ManagerSerivce的桥梁。从Android应用层来说，Binder是客户端和服务端进行通信的媒介。</p>
<p>目前已知，在Android里面Binder主要用在Service中，包括AIDL和Messenger。</p>
<p>所有可以在Binder中传输的接口都需要继承接口IInterface接口。比如在使用AIDL的时候，我们新建如下：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IBookManager.aidl</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">     <span class="function">List&lt;String&gt; <span class="title">getBookList</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">addBook</span><span class="params">(String book)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>然后你再build一下，会在build文件里面生成类IBookManager.java类：乍一看很复杂其实很简单。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Local-side IPC implementation stub class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">android</span>.<span class="title">findme</span>.<span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR = <span class="string">&quot;com.example.android.findme.IBookManager&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Construct the stub at attach it to the interface.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Stub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.attachInterface(<span class="keyword">this</span>, DESCRIPTOR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Cast an IBinder object into an com.example.android.findme.IBookManager interface,</span></span><br><span class="line"><span class="comment">         * generating a proxy if needed.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> com.example.android.findme.<span class="function">IBookManager <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">            <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> com.example.android.findme.IBookManager))) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((com.example.android.findme.IBookManager) iin);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> com.example.android.findme.IBookManager.Stub.Proxy(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">            java.lang.String descriptor = DESCRIPTOR;</span><br><span class="line">            <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">                <span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">                    reply.writeString(descriptor);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> TRANSACTION_getBookList: &#123;</span><br><span class="line">                    data.enforceInterface(descriptor);</span><br><span class="line">                    java.util.List&lt;java.lang.String&gt; _result = <span class="keyword">this</span>.getBookList();</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    reply.writeStringList(_result);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> TRANSACTION_addBook: &#123;</span><br><span class="line">                    data.enforceInterface(descriptor);</span><br><span class="line">                    java.lang.String _arg0;</span><br><span class="line">                    _arg0 = data.readString();</span><br><span class="line">                    <span class="keyword">this</span>.addBook(_arg0);</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">default</span>: &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">android</span>.<span class="title">findme</span>.<span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line"></span><br><span class="line">            Proxy(android.os.IBinder remote) &#123;</span><br><span class="line">                mRemote = remote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mRemote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getInterfaceDescriptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> java.util.List&lt;java.lang.String&gt; getBookList() <span class="keyword">throws</span> android.os.RemoteException &#123;</span><br><span class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">                java.util.List&lt;java.lang.String&gt; _result;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, <span class="number">0</span>);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                    _result = _reply.createStringArrayList();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> _result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(java.lang.String book)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    _data.writeString(book);</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, <span class="number">0</span>);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> java.util.List&lt;java.lang.String&gt; getBookList() <span class="keyword">throws</span> android.os.RemoteException;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(java.lang.String book)</span> <span class="keyword">throws</span> android.os.RemoteException</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></div></figure>
<p>首先他声明了两个方法，getBookList和addBook，很显然就是我们在IBookManager.aidl中声明的方法，然后还声明了两个id，分别对应这两个方法。然后就是申明了一个内部类Stub继承Binder。</p>
<p>从上面的分析看来。我们其实可以不用生命adil文件就可以实现Binder。之所以android提供这个aidl文件，其实是帮助我们生成代码。</p>
<p>**asInterface(IBinder obj)**：<br>用于将服务端的Binder对象转换成客户端所需要的aidl接口类的对象。如果客户端和服务端属于同一个进程，那么此方法返回的就是服务端的Stub对象本身，否则返回是系统封装后的Stub.proxy对象。</p>
<p><strong>asBinder</strong>：<br>此方法返回当前Binder对象。</p>
<p>Binder里面还有两个重要方法：</p>
<ol>
<li>linkToDeath</li>
<li>unlinkToDeath</li>
</ol>
<p>在Binder发生断裂的时候死亡的时候，linkToDeth方法会收到回调。让客户端知道服务端是否死亡了。</p>

        <h1 id="IPC">
          <a href="#IPC" class="heading-link"><i class="fas fa-link"></i></a><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h1>
      
        <h2 id="使用Bundle">
          <a href="#使用Bundle" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用Bundle" class="headerlink" title="使用Bundle"></a>使用Bundle</h2>
      <p>优点：简单易用</p>
<p>缺点：只能传输Bundle支持的数据类型</p>
<p>使用场景：四大组件进行进程间的通信</p>

        <h2 id="使用文件共享">
          <a href="#使用文件共享" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用文件共享" class="headerlink" title="使用文件共享"></a>使用文件共享</h2>
      <p>缺点：不适合高并发场景，并且无法做到进程间的即时通信</p>
<p>场景：无并发访问情景，交换简单的数据，实时性不高的场景</p>

        <h2 id="使用Messenger">
          <a href="#使用Messenger" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用Messenger" class="headerlink" title="使用Messenger"></a>使用Messenger</h2>
      <p>优点：功能一般，支持一对多串行通信，支持实时通信</p>
<p>缺点：不能很好的处理高并发，不支持rpc，数据通过message进行传输</p>
<p>是对AIDL的封装，主要用来传递Message。不能直接在服务端调用客户端的方法。Messenger是通过Handler来传递消息的。</p>

        <h2 id="使用AIDL">
          <a href="#使用AIDL" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用AIDL" class="headerlink" title="使用AIDL"></a>使用AIDL</h2>
      <p>功能强大，支持一对多并发通信，支持实时性</p>
<p>缺点：使用复杂，需要处理好线程同步</p>
<ol>
<li>Messenger对消息的处理是串行的，不支持并行。这里使用还有个知识点就是使用RemoteCallbackList用于删除进程listener的接口。</li>
<li>权限验证功能：我们的远程服务并不希望任何人都可以连接。<br>实现方式：</li>
</ol>
<p>1.1 在onBind中进行验证：<br>首先在AndroidMenifest里面申明权限：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;permission </span><br><span class="line">android:name=&quot;com.tgf.ds.permission.ACCESS_BOOK_SERVICE&quot;</span><br><span class="line">android:protectionLevel=&quot;normal&quot;/&gt;</span><br></pre></td></tr></table></div></figure>
<p>然后在obBind里面进行验证：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public onBind(Intent intent)&#123;</span><br><span class="line">    int chek = checkCallingOrSelfPermission(&quot;com.tgf.ds.permission.ACCESS_BOOK_SERVICE&quot;);</span><br><span class="line">    if(chek == PackageManager.PERMISSION_DENIED)&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    return mBinder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>1.2 在服务端的onTranscat方法进行验证。如果验证失败就直接返回false。</p>

        <h2 id="使用ContentProvider">
          <a href="#使用ContentProvider" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用ContentProvider" class="headerlink" title="使用ContentProvider"></a>使用ContentProvider</h2>
      <p>优点：在数据访问方面功能强大，支持一对多并发数据共享，可通过call进行方法扩展操作</p>
<p>缺点：受约束的aidl</p>
<p>他是专门用于不用应用间数据共享的方式。</p>

        <h2 id="使用socket">
          <a href="#使用socket" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用socket" class="headerlink" title="使用socket"></a>使用socket</h2>
      
        <h1 id="Binder连接池">
          <a href="#Binder连接池" class="heading-link"><i class="fas fa-link"></i></a><a href="#Binder连接池" class="headerlink" title="Binder连接池"></a>Binder连接池</h1>
      <p>当有10个aidl需要进行进程间的通信，那应该怎么处理，总不能新建10个服务一次进行绑定吧。我们需要将所有的aidl放在一个service里面去处理。这是实现好的demo:</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ICompute.aidl</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ICompute</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ISecurityCenter.aidl</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ISecurityCenter</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">encrypt</span><span class="params">(String content)</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">decrypy</span><span class="params">(String password)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IBinderPool.aidl</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IBinderPool</span> </span>&#123;</span><br><span class="line">   <span class="function">IBinder <span class="title">queryBinder</span><span class="params">(<span class="keyword">int</span> binderCode)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ComputeImpl.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputeImpl</span> <span class="keyword">extends</span> <span class="title">ICompute</span>.<span class="title">Stub</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SecurityCenterImpl.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityCenterImpl</span> <span class="keyword">extends</span> <span class="title">ISecurityCenter</span>.<span class="title">Stub</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span> SECREPT_CODE = <span class="string">&#x27;^&#x27;</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">encrypt</span><span class="params">(String content)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = content.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;chars.length;i++)&#123;</span><br><span class="line">            chars[i]^=SECREPT_CODE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decrypy</span><span class="params">(String password)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> encrypt(password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BinderPoolImpl.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinderPoolImpl</span> <span class="keyword">extends</span> <span class="title">IBinderPool</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">queryBinder</span><span class="params">(<span class="keyword">int</span> binderCode)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        IBinder binder = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (binderCode) &#123;</span><br><span class="line">            <span class="keyword">case</span> BinderPool.BINDER_SECURITY_CENTER:</span><br><span class="line">                binder = <span class="keyword">new</span> SecurityCenterImpl();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BinderPool.BINDER_COMPUTER:</span><br><span class="line">                binder = <span class="keyword">new</span> ComputeImpl();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> binder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BinderPoolService.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinderPoolService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;BinderPoolService&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> Binder mBinderPool = <span class="keyword">new</span> BinderPoolImpl();</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBinderPool;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BinderPool.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinderPool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;BinderPool&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BINDER_NONE = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BINDER_COMPUTER = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BINDER_SECURITY_CENTER = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">    <span class="keyword">private</span> IBinderPool mIBinderPool;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> BinderPool sInstance;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch mConnectBinderPoolCountDownLatch;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BinderPool</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        mContext = context.getApplicationContext();</span><br><span class="line">        connectBinderPoolService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BinderPool <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (BinderPool.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sInstance = <span class="keyword">new</span> BinderPool(context);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">connectBinderPoolService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mConnectBinderPoolCountDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        Intent service = <span class="keyword">new</span> Intent(mContext, BinderPoolService.class);</span><br><span class="line">        mContext.bindService(service, mBinderPoolConnection, Context.BIND_EXTERNAL_SERVICE);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mConnectBinderPoolCountDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">queryBinder</span><span class="params">(<span class="keyword">int</span> binderCode)</span> </span>&#123;</span><br><span class="line">        IBinder iBinder = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (mIBinderPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                iBinder = mIBinderPool.queryBinder(binderCode);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> iBinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServiceConnection mBinderPoolConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            mIBinderPool = IBinderPool.Stub.asInterface(service);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mIBinderPool.asBinder().linkToDeath(mBinderDeathRecipient, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            mConnectBinderPoolCountDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IBinder.DeathRecipient mBinderDeathRecipient = <span class="keyword">new</span> IBinder.DeathRecipient() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binderDied</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            mIBinderPool.asBinder().unlinkToDeath(mBinderDeathRecipient, <span class="number">0</span>);</span><br><span class="line">            mIBinderPool = <span class="keyword">null</span>;</span><br><span class="line">            connectBinderPoolService();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>在MainActivity.java进行使用：</p>
<figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">dowork</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> binderPool = BinderPool.getInstance(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">var</span> securityBinder = binderPool.queryBinder(BinderPool.BINDER_SECURITY_CENTER)</span><br><span class="line">    <span class="keyword">var</span> mSecurityCenter = SecurityCenterImpl.asInterface(securityBinder)</span><br><span class="line">    <span class="keyword">var</span> password = mSecurityCenter.encrypt(<span class="string">&quot;Hellp=Android&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;encrty:<span class="subst">$&#123;password&#125;</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;dectypt:<span class="subst">$&#123;mSecurityCenter.decrypy(password)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> computeBinder = binderPool.queryBinder(BinderPool.BINDER_COMPUTER)</span><br><span class="line">    <span class="keyword">var</span> mComoute = ComputeImpl.asInterface(computeBinder)</span><br><span class="line">    println(<span class="string">&quot;3+5=<span class="subst">$&#123;mComoute.add(<span class="number">3</span>,<span class="number">5</span>)&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/28/Glide%E4%B8%AD%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98%E5%88%86%E7%B1%BB/">Glide中内存缓存分类</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-28</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2023-04-26</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>Glide内存缓存：<br>首先你要知道什么时候用到了内存缓存：答案是在：engine.load的时候：当从内存缓存里面找到了可以使用的engineSource时候，就会把当前的engineSource添加到活动缓存里面。<br></p>
<p>其实内存缓存分为两个：</p>
<pre><code>1. 活动缓存activityReources
1. 内存缓存LruResourceCache。
</code></pre>
<p>他们两个缓存的数据不会重复。当系统发生gc的时候，所有的数据会从activityResources里面移除放进LreResourceCache里面。然后当从LruResourceCache里面查到数据的时候会从LruResourceCache里面移除然后添加到activityResources里面。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engine</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> EngineResource&lt;?&gt; loadFromMemory(</span><br><span class="line">        EngineKey key, <span class="keyword">boolean</span> isMemoryCacheable, <span class="keyword">long</span> startTime) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isMemoryCacheable) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 看活动缓存能拿到东西不</span></span><br><span class="line">      EngineResource&lt;?&gt; active = loadFromActiveResources(key);</span><br><span class="line">      <span class="keyword">if</span> (active != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> active;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//看内存缓存能拿到数据不</span></span><br><span class="line">      EngineResource&lt;?&gt; cached = loadFromCache(key);</span><br><span class="line">      <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cached;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可以看到如果在内存缓存里面找到了engineSource,那么就把engineSource添加到活动缓存里面。</span></span><br><span class="line">    <span class="keyword">private</span> EngineResource&lt;?&gt; loadFromCache(Key key) &#123;</span><br><span class="line">      EngineResource&lt;?&gt; cached = getEngineResourceFromCache(key);</span><br><span class="line">      <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cached.acquire();</span><br><span class="line">        activeResources.activate(key, cached);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> cached;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EngineResource&lt;?&gt; getEngineResourceFromCache(Key key) &#123;</span><br><span class="line">    <span class="comment">// 找到了就会从内存缓存里面进行移除</span></span><br><span class="line">      Resource&lt;?&gt; cached = cache.remove(key);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> EngineResource&lt;?&gt; result;</span><br><span class="line">      <span class="keyword">if</span> (cached == <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cached <span class="keyword">instanceof</span> EngineResource) &#123;</span><br><span class="line">        result = (EngineResource&lt;?&gt;) cached;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result =</span><br><span class="line">            <span class="keyword">new</span> EngineResource&lt;&gt;(</span><br><span class="line">                cached, <span class="comment">/*isMemoryCacheable=*/</span> <span class="keyword">true</span>, <span class="comment">/*isRecyclable=*/</span> <span class="keyword">true</span>, key, <span class="comment">/*listener=*/</span> <span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>内存缓存也就是LruResourceCache，需要我们进行深度学习一下：LruResourceCahce里面用到了LinkedHashMap。为什么不用hashMap呢。因为hashMap是无序的，在Glide的内存缓存里面，需要在数据达到限制的时候去删除最近最少使用的数据，那我们既然要知道数据是不是最近最少使用的话，就要使用到Linkedhashmap的特性。他通过牺牲空间和时间维护了一个双向链表来保证迭代顺序。<br></p>
<p>来看下LruResourceCached的put操作：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LruCache.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Y <span class="title">put</span><span class="params">(<span class="meta">@NonNull</span> T key, <span class="meta">@Nullable</span> Y item)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> itemSize = getSize(item);</span><br><span class="line">  <span class="keyword">if</span> (itemSize &gt;= maxSize) &#123;</span><br><span class="line">    onItemEvicted(key, item);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (item != <span class="keyword">null</span>) &#123;</span><br><span class="line">    currentSize += itemSize;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Nullable</span> Entry&lt;Y&gt; old = cache.put(key, item == <span class="keyword">null</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> Entry&lt;&gt;(item, itemSize));</span><br><span class="line">  <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">    currentSize -= old.size;</span><br><span class="line">    <span class="keyword">if</span> (!old.value.equals(item)) &#123;</span><br><span class="line">      onItemEvicted(key, old.value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  evict();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> old != <span class="keyword">null</span> ? old.value : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">evict</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  trimToSize(maxSize);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 超过缓存限制的时候删除最近最少使用的节点。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;</span><br><span class="line">  Map.Entry&lt;T, Entry&lt;Y&gt;&gt; last;</span><br><span class="line">  Iterator&lt;Map.Entry&lt;T, Entry&lt;Y&gt;&gt;&gt; cacheIterator;</span><br><span class="line">  <span class="keyword">while</span> (currentSize &gt; size) &#123;</span><br><span class="line">    cacheIterator = cache.entrySet().iterator();</span><br><span class="line">    last = cacheIterator.next();</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;Y&gt; toRemove = last.getValue();</span><br><span class="line">    currentSize -= toRemove.size;</span><br><span class="line">    <span class="keyword">final</span> T key = last.getKey();</span><br><span class="line">    cacheIterator.remove();</span><br><span class="line">    onItemEvicted(key, toRemove.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<ol>
<li>过大的图片不被允许进行缓存。</li>
<li>每一个EngineResource会被包装在Entry里面</li>
</ol>
<hr>
<p>总结：<br>活动缓存他是通过弱引用的方式将EngeineResource保存在了HashMap里面。这个容量是没有限制的。然后从活动缓存里面移除的数据会被保存在内存缓存也就是LruCachedResource里面。这个里面可以动态设置一个maxSize值用来限制他的大小，当超过这个值的时候他是采用删除最近最少使用的方式来维持缓存大小。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/12/Recycleview%E7%9A%84onMeasure%E8%BF%87%E7%A8%8B%E9%87%8D%E7%9C%8B/">Recycleview的onMeasure过程重看</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-12</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2023-04-26</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>今天我又打开了<code>Recycleview</code>源码进行阅读。这次我深度分析了<code>Recycleview</code>的<code>onMeasure</code>方法。<code>Recycleview</code>的<code>onMeasure</code>方法里面干了很多事情，如果你的<code>Recycleview</code>是自动测量(LinearLayout默认就开启了自动测量)，如果宽高是确定的那么他不会在onMeasure阶段进行预布局，如果是wrap_content的话，那他还要进行预布局在onMeasure阶段就要去测量孩子的大小然后在设置Recycleview的具体宽高值，这样会导致在onMeasure阶段花费更多的时间。</p>
<p></p>想要读懂这个方法我们需要深度了解<code>void onMeasure(int widthSpec,int heightSpec)</code>里面<code>widthSpec和heightSpec</code>参数值的由来。<p></p>
**widthSpec 和 heightSpec**值的由来：<br>他是<code>ViewGroup</code>根据自己的长宽值然后再根据孩子的长宽值，父视图在来设定孩子你最终的长宽是多少。这里讲的有点抽像，现在根据案例还讲解：<br>
这里我拿<code>Linearlayout</code>来举例：
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;100dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;100dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">View</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;#ff5566&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></div></figure>
![截图 2022-10-12 10-47-26.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a373f225da4d4b008ad6e0fd12bcfba7~tplv-k3u1fbpfcp-watermark.image?)

<p>这一看是不是有点纳闷，我的<code>View</code>长宽都设置的<code>wrap_content</code>,那怎么在<code>LinearLayout</code>里面却铺满了整个<code>LinearLayout</code>。只有一个实现办法：<code>LinearLayout</code>发现孩子的宽高是wrap_content的时候，<code>LinearLayout</code>就强制将孩子的宽高设定成了自己的宽高值。也就是上面提到的<code>widthSpec和heightSpec</code>值。现在我们来看下<code>LinearLayout</code>的源码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">            mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</span><br><span class="line">                    + widthUsed, lp.width);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">            mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</span><br><span class="line">                    + heightUsed, lp.height);</span><br><span class="line"></span><br><span class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(spec);</span><br><span class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(spec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size = Math.max(<span class="number">0</span>, specSize - padding);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> resultSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> resultMode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">    <span class="comment">// Parent has imposed an exact size on us</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to be our size. So be it.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to determine its own size. It can&#x27;t be</span></span><br><span class="line">            <span class="comment">// bigger than us.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parent has imposed a maximum size on us</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Child wants a specific size... so be it</span></span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to be our size, but our size is not fixed.</span></span><br><span class="line">            <span class="comment">// Constrain child to not be bigger than us.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to determine its own size. It can&#x27;t be</span></span><br><span class="line">            <span class="comment">// bigger than us.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parent asked to see how big we want to be</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Child wants a specific size... let him have it</span></span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to be our size... find out how big it should</span></span><br><span class="line">            <span class="comment">// be</span></span><br><span class="line">            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</span><br><span class="line">            resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to determine its own size.... find out how</span></span><br><span class="line">            <span class="comment">// big it should be</span></span><br><span class="line">            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</span><br><span class="line">            resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//noinspection ResourceType</span></span><br><span class="line">    <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>源码里面明确写了，当孩子是wrap_content的时候，就将孩子的宽高设置为自己的宽高值。<br><br>现在继续看回<code>Recycleview</code>的<code>onMeasure</code>方法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthSpec, <span class="keyword">int</span> heightSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mLayout == <span class="keyword">null</span>) &#123;</span><br><span class="line">        defaultOnMeasure(widthSpec, heightSpec);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// LinearLayoutManager默认是开启的</span></span><br><span class="line">    <span class="keyword">if</span> (mLayout.isAutoMeasureEnabled()) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthSpec);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightSpec);</span><br><span class="line">        <span class="comment">// 先根据默认的设置recycleview的宽高</span></span><br><span class="line">        mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> measureSpecModeIsExactly =</span><br><span class="line">                widthMode == MeasureSpec.EXACTLY &amp;&amp; heightMode == MeasureSpec.EXACTLY;</span><br><span class="line">        <span class="comment">// 判断当前的recycleview的宽高设置的是不是具体值，是的话就不用进行预加载的过程</span></span><br><span class="line">        <span class="comment">// 预加载过程就是提前执行layout过程，然后计算所需要的宽高，然后在设置给recycleiew</span></span><br><span class="line">        <span class="keyword">if</span> (measureSpecModeIsExactly || mAdapter == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mState.mLayoutStep == State.STEP_START) &#123;</span><br><span class="line">            dispatchLayoutStep1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里就是默认设置父视图规定在没有具体设置宽高值的情况下的值</span></span><br><span class="line">        mLayout.setMeasureSpecs(widthSpec, heightSpec);</span><br><span class="line">        mState.mIsMeasuring = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 进行预备加载 加载完就能知道全部孩子需要的宽高值</span></span><br><span class="line">        dispatchLayoutStep2();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里就已经拿到了孩子全部的具体宽高值，然后在设置给recycleview</span></span><br><span class="line">        mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if RecyclerView has non-exact width and height and if there is at least one child</span></span><br><span class="line">        <span class="comment">// which also has non-exact width &amp; height, we have to re-measure.</span></span><br><span class="line">        <span class="keyword">if</span> (mLayout.shouldMeasureTwice()) &#123;</span><br><span class="line">            mLayout.setMeasureSpecs(</span><br><span class="line">                    MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),</span><br><span class="line">                    MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));</span><br><span class="line">            mState.mIsMeasuring = <span class="keyword">true</span>;</span><br><span class="line">            dispatchLayoutStep2();</span><br><span class="line">            mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>看完Recycleview的测量过程，我认为你能够设置具体值的就最好设置具体值，不然在onMeasure厘面还要在走一比那layout过程。</p>
<p>这里再稍微讲下layout过程，为什么要讲呢，因为有一部分设计到了上面onMeasure的过程，当时困扰了我挺久：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mAdapter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;No adapter attached; skipping layout&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mLayout == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;No layout manager attached; skipping layout&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mState.mIsMeasuring = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (mState.mLayoutStep == State.STEP_START) &#123;</span><br><span class="line">        dispatchLayoutStep1();</span><br><span class="line">        mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">        dispatchLayoutStep2();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mAdapterHelper.hasUpdates() || mLayout.getWidth() != getWidth()</span><br><span class="line">            || mLayout.getHeight() != getHeight()) &#123;<span class="comment">// 3</span></span><br><span class="line">        mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">        dispatchLayoutStep2();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dispatchLayoutStep3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>前面都很容易看懂，问题就在我标记的<strong>3</strong>处。<br></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mLayout.getHeight() != getHeight()</span><br></pre></td></tr></table></div></figure>
<p>现在看下<code>mLayout.getHeight()</code></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LayoutManager.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mHeight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>那这个mHeight是什么时候赋值的呢？</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LayoutManager.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setMeasureSpecs</span><span class="params">(<span class="keyword">int</span> wSpec, <span class="keyword">int</span> hSpec)</span> </span>&#123;</span><br><span class="line">    mWidth = MeasureSpec.getSize(wSpec);</span><br><span class="line">    mWidthMode = MeasureSpec.getMode(wSpec);</span><br><span class="line">    <span class="keyword">if</span> (mWidthMode == MeasureSpec.UNSPECIFIED &amp;&amp; !ALLOW_SIZE_IN_UNSPECIFIED_SPEC) &#123;</span><br><span class="line">        mWidth = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mHeight = MeasureSpec.getSize(hSpec);</span><br><span class="line">    mHeightMode = MeasureSpec.getMode(hSpec);</span><br><span class="line">    <span class="keyword">if</span> (mHeightMode == MeasureSpec.UNSPECIFIED &amp;&amp; !ALLOW_SIZE_IN_UNSPECIFIED_SPEC) &#123;</span><br><span class="line">        mHeight = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>可以看到在调用方法setMeasureSpecs方法时候赋值的，那这个方法又是什么时候调用的：答案在onMeasuere方法的时候，再问具体点就是在还没有进行预加载之前进行的：可以看到标记3的位置。</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">protected void onMeasure(int widthSpec, int heightSpec) &#123;</span><br><span class="line">    if (mLayout == null) &#123;</span><br><span class="line">        defaultOnMeasure(widthSpec, heightSpec);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (mLayout.isAutoMeasureEnabled()) &#123;</span><br><span class="line">        //3</span><br><span class="line">        mLayout.setMeasureSpecs(widthSpec, heightSpec);</span><br><span class="line">        mState.mIsMeasuring = true;</span><br><span class="line">        dispatchLayoutStep2();</span><br><span class="line">        mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>现在<code>mLayout.getHeight</code>搞懂了。我们再来看下<code>getHeight()</code>方法：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final int getHeight() &#123;</span><br><span class="line">    return mBottom - mTop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>这个getHeight是通过mBottom - mTop来获取的。其实就是我们经常获取控件高度的方式。<br>那现在是不是有疑问了，mLayout.getHeight获取的值也是通过测量高度设置进行的，然后getHeight()获取的值就是控件的高度那为什么这两个值会存在不相等的情况呢？<br><br>不想等的问题就出现在onMeasure里面进行了预加载处理。在预加载前给recycleview设置了他的默认宽高。但是在预加载结束后，根据具体的孩子数量算出的高度值才是recycleview真实的宽高值。然后mBottom的值在layout阶段才设置进去的。所以在layout阶段获取到的recycleview的值和在onMeasure里面预加载阶段前获取到的宽高值会存在不同的情况。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/09/26/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4scroll%E6%96%B9%E6%B3%95%E7%A7%BB%E5%8A%A8%E7%9A%84%E6%98%AF%E4%BB%96%E7%9A%84%E5%AD%A9%E5%AD%90/">为什么说scroll方法移动的是他的孩子?</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-09-26</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2023-04-26</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>在思考<code>mScrollX,mScrollY</code>这两个参数对<code>View</code>的绘制会产生什么样的影响的时候，我看了这么个代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">View</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawBackground</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">            canvas.translate(mScrollX, mScrollX);</span><br><span class="line">            background.draw(canvas);</span><br><span class="line">            canvas.translate(-mScrollX, -mScrollX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>看方法名字很容易知道这是绘制背景的。但是我们在实战中会发现调用<code>TextView.scrollBy(10f,10f)</code>的时候,只有<code>TextView</code>的内容移动了位置，但是我们给<code>TextView</code>设置的背景并没有产生移动。带着这个疑问你看源码，在调用<code>background.draw(canvas)</code>之前不是调用了<code>canvas.translate(mScrollX, mScrollX)</code>对画布进行了移动吗？？？？？？为啥我们的背景确并没有进行移动！！！！！！！！！</p><p></p>
<p></p>
<div align="center">
    <img style="center" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc33ef75dd114ba98bdeb79d4a45183c~tplv-k3u1fbpfcp-watermark.image?" width="50%">
</div>

<p></p>

<p><strong>哈哈，你既然看到了这里，想必你也产生了和我同样的问题。现在就带着问题来看源码，为什么我们的背景没有进行移动。</strong></p>
<p>首先对整个<code>View</code>的绘制流程进行源码解析：</p>
<p>ViewRootImpl触发draw(canvas)方法。<br><br>draw(canvas)分四部走。</p>
<ul>
<li><ol>
<li>drawBackground(canvas) ： 绘制背景</li>
</ol>
</li>
<li><ol start="2">
<li>onDraw(canvas) ： 绘制自己</li>
</ol>
</li>
<li><ol start="3">
<li>dispatchDraw(canvas) ： 绘制孩子</li>
</ol>
</li>
<li><ol start="4">
<li>绘制bar(忽略不管)</li>
</ol>
</li>
</ul>
<p>这里我先模拟这么个层级：</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Framelayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ImageView</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Framelayout</span>&gt;</span></span><br></pre></td></tr></table></div></figure>
<p>我来分析下：首先<code>ViewRootImpl</code>调用了<code>FrameLayout</code>的<code>draw(canvas)</code>方法。然后<code>FrameLayout</code>调用了<code>drawBackground</code>绘制了<code>FrameLayout</code>的背景。然后调用了<code>FrameLayout</code>的<code>onDraw(canvas)</code>方法。我们知道自定义<code>ViewGroup</code>的时候很少几乎不会重写<code>onDraw(canvas)</code>方法。只有自定义<code>View</code>的时候才会重写。然后接着调用了<code>FrameLayout</code>的<code>dispatchDraw(canvas)</code>方法。在这个里面会遍历所有的孩子调用<code>child.draw(canvas, this, drawingTime)</code>。<strong>可以看到到了这里就走进了子孩,在这里也就是<code>ImageView</code>的<code>draw(canvas, this, drawingTime)</code>方法</strong>。然后在这个<code>draw(canvas, this, drawingTime)</code>方法里面会调用孩子的<code>draw(canvas)</code>方法。</p><br>注意<strong>重点</strong>来了：我们知道绘制背景的代码是在<code>draw(canvas)</code>这个方法里调用的。现在你想下在绘制背景前会调用<code>canvas.translate(mScrollX, mScrollX)</code>但是最终的现象是调用了这个方法，我们的背景并没有偏移。既然没有偏移，我们是不是可以猜想我们的画布在调用偏移前已经提前偏移过了一次，这次绘制背景前的偏移其实和之之前的偏移只是进行了一个抵消操作，所以我们的背景没有移动。哈哈，其实就是这么个过程，我们刚才分析了<code>ViewGroup</code>的<code>dispatchDraw(canvas)</code>方法。他调用了<code>child.draw(canvas, this, drawingTime)</code>也就是这个方法<code>draw(canvas, this, drawingTime)</code>先于背景的偏移前进行了一次偏移。<p></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">draw</span><span class="params">(Canvas canvas, ViewGroup parent, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sy = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!drawingWithRenderNode) &#123;</span><br><span class="line">        computeScroll();</span><br><span class="line">        sx = mScrollX;</span><br><span class="line">        sy = mScrollY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> drawingWithDrawingCache = cache != <span class="keyword">null</span> &amp;&amp; !drawingWithRenderNode;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> offsetForScroll = cache == <span class="keyword">null</span> &amp;&amp; !drawingWithRenderNode;</span><br><span class="line">    <span class="keyword">if</span> (offsetForScroll) &#123;</span><br><span class="line">        canvas.translate(mLeft - sx, mTop - sy);</span><br><span class="line">    &#125;</span><br><span class="line">   draw(canvas);</span><br><span class="line">   <span class="keyword">return</span> more;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>看在倒数第四行调用了<code>canvas.translate()</code>对视图已经进行了偏移。<br><br>到此为什么我们的背景不会移动已经讲清楚了。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/09/05/%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%90%86%E8%A7%A3/">线程和线程池的理解</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-09-05</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2023-04-26</span></span></div></header><div class="post-body"><div class="post-excerpt"><p> 线程有个异常叫<code>InterruptedException</code>，这个异常是在调用方法<code>interrupt</code>方法触发的。<strong>不是每次调用这个方法都能触发这个异常，条件是：</strong></p>
<ol>
<li>线程处于阻塞态</li>
<li>线程处于限期等待</li>
<li>线程处于无限期等待</li>
</ol>
<p>不能中断I/O阻塞和synchroized锁阻塞。还有就是一个线程你调用了无限循环，这个时候你调用interrupt方法也是没办法使线程提前结束的。但是你可以使用interrupt给线程设上的标记用来停止线程。比如这样：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!interrupted()) &#123;</span><br><span class="line">                <span class="comment">// ..</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread end&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<p>线程池的中断操作：<br>调用<code>shutDown()</code>方法会阻止接收新的任务,但是会继续执行已经提交的任务。但是调用<code>shutDownNow</code>方法，则相当于调用线程的<code>interrupt</code>方法。</p>
<hr>
<p>使用锁有<code>synchronized</code>和<code>ReentrantLock</code>,两者区别是<code>RenntrantLock</code>可以中断，还是公平锁。<br></p>

        <h1 id="线程池">
          <a href="#线程池" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1>
      <p>是否新建线程的流程：</p>
<pre class="mermaid">graph TD
提交任务 ==> 核心线程池是否已经满 
核心线程池是否已经满 ==否==> 创建线程执行任务
核心线程池是否已经满 ==是==> 队列是否已经满了
队列是否已经满了 ==否==> 将任务存储在队列里面
队列是否已经满了 ==是==> 线程池是否已经满了
线程池是否已经满了 ==否==> 创建线程执行任务
线程池是否已经满了 ==是==> 按照策略处理无法执行的任务</pre>
<p>线程池可以设定线程的空闲的存活时间<code>keepAliveTime</code>,当一个线程空闲下来后，超过<code>keepAliveTime</code>时间，线程池会判断当前运行的线程数量是否大于核心线程数量，如果超过了，那么空闲的线程就会被停掉。所以所有任务都完成后，线程池里面的线程数都会收缩到核心线程数大小。<strong>注意：当设置了<code>allowCoreThreadTimeOut</code>不关心线程存活时间，那么在线程空闲下来后，不会判读空闲线程是否超过核心线程数就直接被停掉。所以最终线程数=0</strong><br></p>
<p>线程池里面的<code>BlockingQueue</code>有几种往队列加数据的方法：</p>
<div class="table-container"><table>
<thead>
<tr>
<th></th>
<th>抛出异常</th>
<th>特殊值</th>
<th>阻塞</th>
<th>超时</th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td>add</td>
<td>offer</td>
<td>put</td>
<td>offer(e,time.unit)</td>
</tr>
<tr>
<td>移除</td>
<td>remove</td>
<td>poll</td>
<td>take</td>
<td>poll(time,unit)</td>
</tr>
<tr>
<td>检测</td>
<td>element</td>
<td>peek</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody></table></div>
<ul>
<li>抛出异常：当队列满了，插入的新值插不进去了就会立马抛出一个异常。</li>
<li>特殊值：当插入数据失败，返回一个boolean值，true成功，false失败。然后拿SynchronousQueue调用这个方法的时候，必须有另一个线程执行了取值的操作，这个offer才会返回true。</li>
<li>阻塞：一个线程插入一个数据的时候，必须等到另一个线程执行取数据的操作，不然就一直阻塞当前线程。</li>
<li>超时：插入数据失败在阻塞一个规定的时间。</li>
</ul>
<p>关于使用<code>SynchronousQueue.offer</code>演示：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SynchronousQueue&lt;String&gt; queue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;();</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;取值&quot;</span> + queue.take());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;put 1&quot;</span>);</span><br><span class="line">    System.out.println( <span class="string">&quot;结果：&quot;</span>+queue.offer(<span class="string">&quot;hahah&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;hahaha&quot;</span>);</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></div></figure>
<p>运行这个代码你可以发现，当没调用take这个取值的操作，我们offer返回的结果一直都是false（这个现象只针对SynchronousQueue阻塞队列）。</p>
<hr>
<p><strong>讲一下我对线程池实现的思路分析，线程池里面有个核心线程，非核心线程和任务存储的数据结构。为什么会出现核心线程这个东西，因为线程的开启和关闭开销是很大的，所以在有很多任务需要执行的时候，我们应该有一个办法来实现线程的重复使用。降低线程的频繁创建和关闭的次数。核心线程就是这个作用，核心线程是不会停止的，用阻塞的方式实现线程不会停止，然后当核心线程都在运行的时候，就把任务添加到我们的任务存储的数据结构里面，核心线程一直从任务存储的数据结构里面拿去新任务。当任务存储结构满了，就需要开辟临时线程了，临时线程我们可以给他设置过期时间，当处于空闲后超过过期时间那么这个临时线程就可以停止了。</strong><br></p>
<p>现在看下基于上面的思路是怎么实现的：</p>
<p>现在来分析<code>ThreadPoolExecutor</code>线程池源码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">//1 创建我们的核心线程数量  </span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">    <span class="comment">// addWorker的返回值用来判断新的任务是否添加成功</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *2  调用offer他是不会阻塞线程的，这个方法的返回值要看具体的实现类。</span></span><br><span class="line"><span class="comment">    * 比如拿SyncronousQueue来说，这个队列比较特殊，他不存储任何数据，所以如果你只</span></span><br><span class="line"><span class="comment">    * 调用offer，他的返回值只会是false。只有当你在其他线程调用了workQueue.take或者poll。这里才会返回true。</span></span><br><span class="line"><span class="comment">    * workQueue.offer返回值的含义只代表任务是否添加进队列。添加不进去就代表需要开辟非核心线程了。</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3 线程池第一次提交任务并且线程数小于核心线程数的时候走的是这里。   </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>现在进入只要的addWorker方法：</p>
<figure class="highlight java"><figcaption><span>// core:是核心线程的话就为true 否则为false</span></figcaption><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry: </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *这里有个双循环，外层的循环是判断线程池是否是可运行状态 </span></span><br><span class="line"><span class="comment">    *第二层循环判断线程数量是否已经超过线程数量设定。</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = ctl.get();;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (runStateAtLeast(c, SHUTDOWN)</span><br><span class="line">            &amp;&amp; (runStateAtLeast(c, STOP)</span><br><span class="line">                || firstTask != <span class="keyword">null</span></span><br><span class="line">                || workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c)</span><br><span class="line">                &gt;= ((core ? corePoolSize : maximumPoolSize) &amp; COUNT_MASK))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();   </span><br><span class="line">            <span class="keyword">if</span> (runStateAtLeast(c, SHUTDOWN))</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 这里创建了Worker对象，你查看worker的构造函数，</span></span><br><span class="line">    <span class="comment">// 你会发现在构造函数里面创建了线程thread。</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">                    (runStateLessThan(c, STOP) &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.getState() != Thread.State.NEW)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                <span class="comment">// 开启了线程 这里很关键，哈哈。你第一次看到这里的时候一定蒙蔽，</span></span><br><span class="line">                <span class="comment">// 这里直接调用了thread.start.那核心线程是怎么一直运行下去的还不会停止？</span></span><br><span class="line">                <span class="comment">// 下面我会带你看worker类</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>这里很有必要看下我们的<code>Worker</code>类：<br><br>可以看<code>Worker</code>类继承了<code>Runable</code>,然后在构造函数里面创建了线程<code>Thread</code>并且将自己传了进去自己，一个worker就是一个任务。所以在调用Thread.start的时候，会调用到<code>Worker</code>的<code>run</code>方法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>在<code>runWorker</code>方法里面实现了核心线程的不停运行：<br><br>可以看到在<code>runWorker</code>方法里面有一个<code>while</code>循环，有了while循环我们就知道了，如果getTask方法返回的值如果不是null，那么这个while循环就会一直为true，那我们的线程不就一直运行下去了吗。哈哈</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>现在来看下<code>getTask</code>方法：<br><br>在下面我标记1和2的位置，1的位置用来判断当前线程数是否大于核心线程数：</p>
<ol>
<li>小于的话代表当前线程是核心线程。那么就调用workQueue.take()方法。（在最上面我写了take方法是一个阻塞方法，他会阻塞当前的线程直到其他线程调用了put或者offer方法）。这也就实现了核心线程的永不死亡。</li>
<li>如果不是核心线程就调用workQueue.poll(timeOut,TIME_TYPE)。这个方法实现了延迟线程的死亡。timeOut的值是我们在创建线程池的时候自己设定的。所以非核心线程是会死亡的。<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (runStateAtLeast(c, SHUTDOWN)</span><br><span class="line">            &amp;&amp; (runStateAtLeast(c, STOP) || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">        <span class="comment">//1</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//2 这里是关键。实现了核心线程不死，非核心线程可以死亡。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ol>
<p><strong>至此已经分析完了，核心线程不会死亡的原因。</strong><br></p>
<p>在看了整个任务添加流程（addWork）方法。我们可以看到这个方法返回的是一个boolean变量。用来判读任务添加失败和成功。那什么情况会失败呢？</p>
<p><strong>线程池有五种状态</strong>：他们数值依次变大</p>
<p>int COUNT__BITS = Interger.SIZE - 3</p>
<ul>
<li>  RUNNING  （int RUNNIT = -1 &lt;&lt; COUNT_BITS）</li>
<li>  SHUTDOWN （int SHUTDOWN = 0 &lt;&lt; COUNT_BITS）</li>
<li>  STOP （int STOP = 1 &lt;&lt; COUNT_BITS）</li>
<li>  TIDYING （int TIDYING = 2 &lt;&lt; COUNT_BITS）</li>
<li>  TERMINATED （int TERMINATED = 3 &lt;&lt; COUNT_BITS）</li>
</ul>
<ol>
<li><code>addWorker</code>方法<code>false</code>的情况：<br></li>
</ol>
<ul>
<li>线程池当前状态 <strong>大于等于SHUTDOWN状态</strong> 并且 线程池当前状态<strong>大于等于STOP状态</strong> 或者 是<strong>任务不等于null</strong> 或者 <strong>队列为空</strong> 就返回false。返回false就是拒绝的意思。</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = ctl.get();;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (runStateAtLeast(c, SHUTDOWN)</span><br><span class="line">            &amp;&amp; (runStateAtLeast(c, STOP)</span><br><span class="line">                || firstTask != <span class="keyword">null</span></span><br><span class="line">                || workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//拒绝新任务的添加</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<ol start="2">
<li>线程数超过设置的最大线程数，就拒绝。</li>
</ol>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = ctl.get();;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (runStateAtLeast(c, SHUTDOWN)</span><br><span class="line">            &amp;&amp; (runStateAtLeast(c, STOP)</span><br><span class="line">                || firstTask != <span class="keyword">null</span></span><br><span class="line">                || workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//拒绝新任务的添加</span></span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c)</span><br><span class="line">                    &gt;= ((core ? corePoolSize : maximumPoolSize) &amp; COUNT_MASK))</span><br><span class="line">            <span class="comment">// 超过了设置的最大线程数量就返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<ol start="3">
<li>当线程池处于SHUTDOWN状态并且队列里面已经存在之前已经添加的但还没执行的相同的任务。</li>
</ol>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">    reject(command);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> removed = workQueue.remove(task);</span><br><span class="line">        tryTerminate(); <span class="comment">// In case SHUTDOWN and now empty</span></span><br><span class="line">        <span class="keyword">return</span> removed;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>
<ol start="4">
<li>事物存储的数据结构存不下新的事物的时候，然后非核心线程也到了上限值。</li>
</ol>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// offer：往队列里面添加数据，添加数据失败则返回false</span></span><br><span class="line"><span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">    <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">        reject(command);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;<span class="comment">// 队列里面添加事物失败才会走这个判断</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">    reject(command);</span><br></pre></td></tr></table></div></figure>
<p>这里讲到了拒绝，那就在分析下线程池的拒绝策略:<br><br><strong>java官方实现的拒绝策略有四种：</strong></p>
<pre class="mermaid">classDiagram
RejectedExecutionHandler <|-- abortpolicy rejectedexecutionhandler <|-- callerrunspolicy discardoldestpolicy discardpolicy rejectedexecutionhandler: +regectedexecution()< pre>
<ol>
<li>AbortPolicy终止策略：直接抛出异常RejectedxecutionException</li>
<li>CallerRunsPolicy调用者运行策略：除非线程池现在处于shutDown状态，那么被拒绝的任务将由调用者线程自己处理。</li>
<li>DiscardOldestPolicy如果线程池没shutDown，就丢弃队列里面最久没执行的事物，然后将当前任务添加进线程池里面。</li>
<li>DiscardPolicy默默丢弃任务无任何感知。</li>
</ol>
<p>当然我们可以继承自<code>RejectedExecutionHandler</code>实现<code>recectedExecution</code>方法。</p>
<hr>
<p><strong>shutDown和shutDownNow</strong>的区别：</p>
<ul>
<li>shutDown中断空前的workers。没有任何返回。</li>
<li>showDownNow中断所有的workders,并且返回所有的任务队列里面的任务</li>
</ul>
<hr>
<p>java提供了几个默认的线程池：<br></p>
<ol>
<li>newCachedThreadPool:该线程池可以无限扩展，当需求增加时会自动添加新的线程，当需求降低时，会自动回收空闲线程。通常用来执行许多短期异步任务的程序性能，<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li>newScheduledThreadPool创建一个以延迟或者定时来执行任务的线程池，工作队列为DelayedWorkQueue.适用于需要多个后台线程执行的周期性任务。</li>
<li>newSingleThreadExecutor只有一个线程的线程池，用来执行需要要保证顺序的任务场景。</li>
</ol>
<hr>
<p>一篇挺好的分析线程池源码的文章：<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36602071/article/details/125476743">文章1</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<hr>
<p>创建线程的几种方式:  </p>
<ol>
<li>继承thread<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;<span class="comment">//继承Thread类</span></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">　　<span class="comment">//重写run方法</span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">　　　　<span class="keyword">new</span> MyThread().start();<span class="comment">//创建并启动线程</span></span><br><span class="line">　　&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li>继承Runable<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;<span class="comment">//实现Runnable接口</span></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">　　<span class="comment">//重写run方法</span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">　　　　<span class="comment">//创建并启动线程</span></span><br><span class="line">　　　　MyRunable myRunable=<span class="keyword">new</span> MyRunable();</span><br><span class="line">　　　　Thread thread=<span class="keyword">new</span> Thread(myRunable);</span><br><span class="line">　　　　thread().start();</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></div></figure></li>
<li>使用Callable和FutureTask来创建<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FutureTask futureTask = <span class="keyword">new</span> FutureTask(<span class="keyword">new</span> Callable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;执行任务&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程里的返回值&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">thread.start();</span><br><span class="line">System.out.println(<span class="string">&quot;==:&quot;</span> + futureTask.get());</span><br><span class="line">System.out.println(<span class="string">&quot;结束了&quot;</span>);</span><br></pre></td></tr></table></div></figure>
futureTask.get方法会阻塞当前正在运行的线程.  </li>
<li>使用线程池:<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService mFixedPool = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">Future future = mFixedPool.submit(<span class="keyword">new</span> Callable&lt;Object&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在子线程执行任务&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我是返回值&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;拿到返回值:&quot;</span>+future.get());</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;一切都结束了&quot;</span>);</span><br><span class="line">mFixedPool.shutdown();</span><br></pre></td></tr></table></div></figure></li>
</ol>
<p>实现等待所有线程结束在继续运行的实现有如下几种方式:  </p>
<ol>
<li>使用CountDownLatch</li>
<li>使用join</li>
</ol>
<p>比如main线程想等thread1线程结束了,main在结束,那么在main线程只需要调用thread1.join就行.  </p>
<p>关于线程状态控制的方法的记忆要这么记忆:<br>第一组: wait / notify / notifyAll<br>第二组: join / sleep / yield</p>
<p>join / sleep / yield : 他们会自动到达某个条件就苏醒过来.而 wait 不会,他需要你触发 notify notifyAll 才可以. 那 sleep 和 wait 的区别是,sleep他会阻塞当前线程,并且不会释放对象锁,而wait让当前线程处于等待状态,并且释放对象锁.</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread 1 acquired lock&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread 1 released lock&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread 2 acquired lock&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面代码的运行效果是,t2一直运行不起来,因为t1拿到了对象锁,并且调用了sleep导致锁不能被释放,所以t2也没办法运行下去.</span></span><br></pre></td></tr></table></div></figure>
</|--></pre></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/07/28/Zygote%E8%BF%9B%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E5%88%9B%E5%BB%BA%E5%AD%90%E8%BF%9B%E7%A8%8B%EF%BC%8C%E7%84%B6%E5%90%8E%E8%87%AA%E5%B7%B1%E8%BF%98%E4%B8%80%E7%9B%B4%E5%AD%98%E6%B4%BB%E7%9D%80%E3%80%82/">Zygote进程为什么可以创建子进程，然后自己还一直存活着。</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-07-28</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2023-04-26</span></span></div></header><div class="post-body"><div class="post-excerpt"><blockquote>
<p>携手创作，共同成长！这是我参与「掘金日新计划 · 8 月更文挑战」的第1天，<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://juejin.cn/post/7123120819437322247" title="https://juejin.cn/post/7123120819437322247">点击查看活动详情</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p><strong>首先简单分析下Zygote进程的启动流程：<br></strong><br><code>init.cpp</code>会去读取<code>init.rc</code>内容，在<code>init.rc</code>可以看到这么一句话：</p>
<p><code>import /system/etc/init/hw/init.$&#123;ro.zygote&#125;.rc </code>。这个就是通过系统版本加载对应的init.zygote64.rc和init.zygote32.rc两个文件。</p>
<p>然后就会加载类<code>app_main.cpp</code>,在<code>app_main.cpp</code>的main函数里面可以看到去创建了Zygote进程。并且进程名字就叫zygote。</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> ZYGOTE_NICE_NAME[] = <span class="string">&quot;zygote&quot;</span>;</span><br><span class="line"><span class="comment">//....省略部分代码</span></span><br><span class="line"><span class="keyword">if</span> (!niceName.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">      runtime.<span class="built_in">setArgv0</span>(niceName.<span class="built_in">string</span>(), <span class="literal">true</span> <span class="comment">/* setProcName */</span>);<span class="comment">//设置进程名字</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (zygote) &#123;</span><br><span class="line">        runtime.<span class="built_in">start</span>(<span class="string">&quot;com.android.internal.os.ZygoteInit&quot;</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className) &#123;</span><br><span class="line">        runtime.<span class="built_in">start</span>(<span class="string">&quot;com.android.internal.os.RuntimeInit&quot;</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Error: no class name or --zygote supplied.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">app_usage</span>();</span><br><span class="line">        <span class="built_in">LOG_ALWAYS_FATAL</span>(<span class="string">&quot;app_process: no class name or --zygote supplied.&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>
<p> <code>Zygote</code>创建子进程的方式是通过fork函数来创建，这里我们需要搞懂父进程和子进程的关系。</p><p></p>
<p> <strong>父进程&amp;子进程</strong><br></p>
<p>子进程拥有父进程的全部资源包括代码。那你可能要问了，那子进程从代码哪个地方开始执行？答案是。从fork那个位置开始执行，fork之前的代码子进程不会去执行，他只会执行fork这行代码下面的代码。fork会返回一个pid。这个pid=0代表这是一个子进程，pid&lt;0代表子进程创建失败，pid&gt;0代表是父进程。我们就是通过这个pid的值来判断某些功能让谁来做。这里你可能又有问题了，那父进程在fork之前创建的对象比如Student，那在子进程里面，这个在fork之前创建的对象，他的指向地址和父进程是一样的吗？答案告诉你，是一样的。你在子进程打印出的Student对象地址和父进程打印的Student地址是一样的。那我在给你提个问题，那既然一样，我在子进程修改Student.name值，那父进程里面在获取这个name的值，是子进程修改的值吗？答案是：不是的。子进程修改值不会影响到父进程。因为在子进程那个地址是一个虚拟地址，真正指向的物理地址并不是那个。</p><p></p>
<hr>
<p> 在我第一次看<code>ZygoteInit.java</code>这个类的时候,我一直不明白为什么zygote进程能够一直存活，<br> <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">            Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer);</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                r.run();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        caller = zygoteServer.runSelectLoop(abiList);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;System zygote died with fatal exception&quot;</span>, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (zygoteServer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            zygoteServer.closeServerSocket();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">        caller.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><br>比如创建<code>systemServer</code>进程的时候，当创建完成后，这个runable一定是不为null的。所以就会执行r.run方法。然后执行return。这里都return了。那为什么zygote进程还是活着的，不是应该死掉了吗。<br><br>来看下<code>forkSystemServer</code>方法：</p>
 <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private static Runnable forkSystemServer(String abiList, String socketName,</span><br><span class="line">        ZygoteServer zygoteServer) &#123;</span><br><span class="line">    ZygoteArguments parsedArgs;</span><br><span class="line">    int pid;</span><br><span class="line">    try &#123;</span><br><span class="line">        pid = Zygote.forkSystemServer(</span><br><span class="line">                parsedArgs.mUid, parsedArgs.mGid,</span><br><span class="line">                parsedArgs.mGids,</span><br><span class="line">                parsedArgs.mRuntimeFlags,</span><br><span class="line">                null,</span><br><span class="line">                parsedArgs.mPermittedCapabilities,</span><br><span class="line">                parsedArgs.mEffectiveCapabilities);</span><br><span class="line">    &#125; catch (IllegalArgumentException ex) &#123;</span><br><span class="line">        throw new RuntimeException(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* For child process */</span><br><span class="line">    if (pid == 0) &#123;</span><br><span class="line">        if (hasSecondZygote(abiList)) &#123;</span><br><span class="line">            waitForSecondaryZygote(socketName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        zygoteServer.closeServerSocket();</span><br><span class="line">        return handleSystemServerProcess(parsedArgs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>哈哈你看懂了吗。我们可以看到里面执行了<code>Zygote.forkSystemServer</code>方法去创建了子进程。然后当pid=0的时候去创建了Runbale对象，当pid不是0的时候，返回null。现在在回到ZygoteInit.java里面：<br> <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">            Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer);</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                r.run();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><br>可以看到当是主进程的时候，这个r是等于null的，所以主进程不会走进return。所以主进程这个时候也不会死。同理你可以去看runSelectLoop方法，他里面有个while的死循环，这就让这个zygote进程可以一直活着了。<br><strong>想搞懂zygote进程不会死的原因，你一定要先搞懂父进程和子进程的原理和执行逻辑。</strong></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/05/26/%E5%85%B3%E4%BA%8EDrawable%E7%9A%84%E5%AD%A6%E4%B9%A0/">关于Drawable的学习</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-05-26</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2023-04-26</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>本文已参与[新人创作礼]活动，一起开启掘金创作之路。</p>
<p>首先要搞清楚官方为什么要设计出<code>Drawable</code>，而且还允许我们进行自定义。</p>
<p>这个问题可以通过阅读<code>View</code>源码找到答案。<code>View</code>都有一个drawable属性。在<code>draw(canvas)</code>方法里面我们可以看到调用了drawable.draw(canvas)方法，可以看到将画布对象传了进去。谷哥官方也就是通过这种方式将绘制背景的操作单独提取了出来。</p>

<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">View</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        drawBackground(canvas);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawBackground</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Drawable background = mBackground;</span><br><span class="line">        <span class="keyword">if</span> (background == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        setBackgroundBounds();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> scrollX = mScrollX;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> scrollY = mScrollY;</span><br><span class="line">        <span class="keyword">if</span> ((scrollX | scrollY) == <span class="number">0</span>) &#123;</span><br><span class="line">            background.draw(canvas);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            canvas.translate(scrollX, scrollY);</span><br><span class="line">            background.draw(canvas);</span><br><span class="line">            canvas.translate(-scrollX, -scrollY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>所以单独设计一个<code>Drawable</code>的目的在我看来是为了让代码不杂揉在<code>view</code>里面。比如你要给<code>view</code>设置一个背景，改变<code>view</code>的形状。有了画布<code>canvas</code>我们就能干任何事情，<code>drawable</code>就是帮助我们在展示我们想要展示的东西之前帮我们做一些不是那么主要的事情。</p>

<hr>
<p>上面讲了我对<code>drawable</code>的理解，现在就要实际使用一下他了。</p><br>在使用前有个我自认为很重要的知识点需要讲下，为什么在自定义Drawable里面调用<code>invalidateSelf()</code>方法没有效果出现？答：因为你的自定义<code>Drawable</code>没有继承<code>Drawable.Callback</code>接口，然后实现方法<code>invalidateDrawable(Drawble who)</code>。我们来看下<code>View</code>类。可以看到他继承了<code>Drawable.Callback</code>,然后实现了<code>invalidateDrawable方法</code>，在里面调用了<code>invalidate()</code>实现了页面刷新。<p></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">View</span> <span class="keyword">implements</span> <span class="title">Drawable</span>.<span class="title">Callback</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidateDrawable</span><span class="params">(<span class="meta">@NonNull</span> Drawable drawable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (verifyDrawable(drawable)) &#123;</span><br><span class="line">            <span class="keyword">final</span> Rect dirty = drawable.getDirtyBounds();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> scrollX = mScrollX;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> scrollY = mScrollY;</span><br><span class="line"></span><br><span class="line">            invalidate(dirty.left + scrollX, dirty.top + scrollY,</span><br><span class="line">                    dirty.right + scrollX, dirty.bottom + scrollY);</span><br><span class="line">            rebuildOutline();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>然后我们在<code>View的setBackgroundDrawable</code>方法找到他们给Drawable设置了回调：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBackgroundDrawable</span><span class="params">(Drawable background)</span></span>&#123;</span><br><span class="line">    background.setCallback(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>所以我们在写自定义Drawable的时候一定要继承Drawable.Callback接口，实现invalidateDrawable方法。套路如下:不然回调不到上层view方法从而调用不到invalidate方法。</p><p></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidateDrawable</span><span class="params">(Drawable who)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Callback callback = getCallback();</span><br><span class="line">    <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        callback.invalidateDrawable(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>关于图片的具体大小我们可以重写<code>getIntrinsicWidth()和getIntrinsicHeight</code>来设置图片大小值。默认是-1。</p><br>现在实现一个点击图片，图片渐变的效果。<p></p>
<div align="center">
    <img style="center" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e57625f8b60246229c21fd9585391cac~tplv-k3u1fbpfcp-watermark.image" width="20%">
</div>

<p>绘制思路：对画布上面进行裁切，先绘制正常的图片，然后对画布进行下面裁切，绘制有蒙板的颜色。蒙板的颜色也就是设置colorFilter属性。</p>
<figure class="highlight kotlin"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">draw</span><span class="params">(canvas: <span class="type">Canvas</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mDrawable == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">var</span> rect = bounds</span><br><span class="line">    <span class="keyword">var</span> curOffset = mPercent * rect.height()</span><br><span class="line">    canvas.save()</span><br><span class="line">    canvas.clipRect(rect.left.toFloat(),rect.top.toFloat(),rect.width().toFloat(),rect.height() - curOffset)</span><br><span class="line">    mDrawable.colorFilter = mDefaultColorFilter</span><br><span class="line">    mDrawable.draw(canvas)</span><br><span class="line">    canvas.restore()</span><br><span class="line">    canvas.save()</span><br><span class="line">    canvas.clipRect(rect.left.toFloat(), rect.height() - curOffset, rect.width().toFloat(), rect.height().toFloat());</span><br><span class="line">    mDrawable.colorFilter= mPercentColorFilter</span><br><span class="line">    mDrawable.draw(canvas)</span><br><span class="line">    canvas.restore()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<hr>
<p><strong>总知关于drawable的自定义还需要多练习，我们现在知道了他其实就是帮我们在自定义view的时候把一些操作从view里面提取出来，防止view过于臃肿。基于这个思想你就可以自行改造了。</strong></p><p></p>
<blockquote>
<p>学习过程遇到的一个好的<a href="%22https://blog.csdn.net/yanbober/article/details/56844869%22">博客推荐</a></p>
</blockquote>
<hr>
<p>中途添加的知识点：</p>
<p>调用方法：<code>view.setBackgroundResource(id)</code>可能会触发<code>requestlayout</code>方法。在不知不觉的时候造成了性能浪费。<br><br>源码解析：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBackgroundResource</span><span class="params">(<span class="meta">@DrawableRes</span> <span class="keyword">int</span> resid)</span> </span>&#123;</span><br><span class="line">    Drawable d = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (resid != <span class="number">0</span>) &#123;</span><br><span class="line">        d = mContext.getDrawable(resid);</span><br><span class="line">    &#125;</span><br><span class="line">    setBackground(d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBackground</span><span class="params">(Drawable background)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//noinspection deprecation</span></span><br><span class="line">    setBackgroundDrawable(background);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBackgroundDrawable</span><span class="params">(Drawable background)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (background == mBackground) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> requestLayout = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (background != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mBackground == <span class="keyword">null</span></span><br><span class="line">                || mBackground.getMinimumHeight() != background.getMinimumHeight()</span><br><span class="line">                || mBackground.getMinimumWidth() != background.getMinimumWidth()) &#123;</span><br><span class="line">            requestLayout = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mBackground = background;</span><br><span class="line">        background.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) != <span class="number">0</span>) &#123;</span><br><span class="line">            mPrivateFlags &amp;= ~PFLAG_SKIP_DRAW;</span><br><span class="line">            requestLayout = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mBackground = <span class="keyword">null</span></span><br><span class="line">        requestLayout = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (requestLayout) &#123;</span><br><span class="line">        requestLayout();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></div></figure>
<p>可以看到当我们设置的新图片和老图片的大小不相等的时候就会认为需要重新布局，所以解决办法就是我们可以手动设置图片的大小相等用来避免这个不必要出现的资源浪费。</p>
<hr>
<p>新学到的知识：制作涟漪效果可以使用<code>RippleDrawable</code>.</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ripple</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:color</span>=<span class="string">&quot;#FF0000&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">&quot;@android:id/mask&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:drawable</span>=<span class="string">&quot;@android:color/white&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">ripple</span>&gt;</span></span><br></pre></td></tr></table></div></figure>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/04/26/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8Glide%E4%B8%8D%E5%BD%93%E5%AF%BC%E8%87%B4%E7%9A%84ui%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/">记录一次使用Glide不当导致的ui显示问题</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-04-26</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2023-04-26</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>手机需要显示一个长条的图片:</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/800233ae86a14e8685c7d823afed8064~tplv-k3u1fbpfcp-watermark.image" alt="bg1@3x.png"><br>Downsampler decodeFromWrappedStreams<br><strong>手机:</strong></p>
<div class="table-container"><table>
<thead>
<tr>
<th>手机</th>
<th>分辨率</th>
<th>density</th>
</tr>
</thead>
<tbody><tr>
<td>oppo</td>
<td>1440 * 3216</td>
<td>640</td>
</tr>
<tr>
<td>小米</td>
<td>1440 * 3200</td>
<td>560</td>
</tr>
</tbody></table></div>
<p><strong>加载的图片:</strong></p>
<ul>
<li>大小: 1125 * 147</li>
</ul>
<p>**加载方式: **</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;ImageView</span><br><span class="line">    android:id=<span class="string">&quot;@+id/ivFootBack2&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;49dp&quot;</span></span><br><span class="line">   /&gt;</span><br><span class="line">    </span><br><span class="line"> Glide.with(<span class="keyword">this</span><span class="meta">@MainActivity</span>).load(<span class="keyword">default</span>).into(ivFootBack2)</span><br></pre></td></tr></table></div></figure>
<p><strong>效果:</strong></p>
<div class="table-container"><table>
<thead>
<tr>
<th>手机</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>oppo</td>
<td>手机有多宽图片就可以显示多宽</td>
</tr>
<tr>
<td>小米</td>
<td>图片宽度达不到铺满屏幕宽度,效果就是只显示了一断</td>
</tr>
<tr>
<td>错误:</td>
<td></td>
</tr>
<tr>
<td><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be8e2e3b5de748828c234b07606f323b~tplv-k3u1fbpfcp-watermark.image" alt="captrue.png"></td>
<td></td>
</tr>
<tr>
<td>正确:</td>
<td></td>
</tr>
<tr>
<td><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d36d526409ec4a9ea52aad6af138004f~tplv-k3u1fbpfcp-watermark.image" alt="captrue.png"></td>
<td></td>
</tr>
</tbody></table></div>
<p>你现在是不是也超级纳闷了,为什么会这样.</p>
<p><strong style="color: rgb(53, 148, 247); font-weight: bold; visibility: visible;">「Bitmap」</strong></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/02/22/Mosquitto%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8/">Mosquitto第一次使用</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-02-22</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2023-04-26</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>输入<code>mosquitto -h</code>:</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mosquitto version 2.0.11</span><br><span class="line"></span><br><span class="line">mosquitto is an MQTT v5.0/v3.1.1/v3.1 broker.</span><br><span class="line"></span><br><span class="line">Usage: mosquitto [-c config_file] [-d] [-h] [-p port]</span><br><span class="line"></span><br><span class="line"> -c : specify the broker config file.</span><br><span class="line"> -d : put the broker into the background after starting.</span><br><span class="line"> -h : display this help.</span><br><span class="line"> -p : start the broker listening on the specified port.</span><br><span class="line">      Not recommended in conjunction with the -c option.</span><br><span class="line"> -v : verbose mode - enable all logging types. This overrides</span><br><span class="line">      any logging options given in the config file.</span><br><span class="line"></span><br><span class="line">See https://mosquitto.org/ for more information</span><br></pre></td></tr></table></div></figure>
<ul>
<li>-c表示指定<code>mosquitto</code>的配置文件（默认是：/etc/mosquitto/mosquitto.conf）</li>
<li>-d表示启动一个后台进程（也就是守护进程）来运行我们的服务器</li>
<li>-p指定端口号</li>
</ul>
<p><strong>启动服务器的方法：</strong><br></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mosquitto -c /etc/mosquitto/mosquitto.conf -p 1883</span><br></pre></td></tr></table></div></figure>
<p>和</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mosquitto start</span><br></pre></td></tr></table></div></figure>
<p>这两个命令是相同的。因为默认的配置文件就是<code>/etc/mosquitto/mosquitto.conf</code>，默认的端口号就是1883。</p>
<p>我们想看有没有启动成功可以执行：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">la@lll:~$ ps -aux | grep mosquitto</span><br><span class="line">mosquit+   16064  0.0  0.0  15772  8120 ?        Ss   15:05   0:00 /usr/sbin/mosquitto -c /etc/mosquitto/mosquitto.conf</span><br><span class="line">la@lll:~$ </span><br></pre></td></tr></table></div></figure>
<p>杀进程 kill -9 16064。br&gt;</p>
<p>如果我们的服务器没有启动执行命令<code>mosquitto_sub -t "test"</code>会报错：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">la@lll:~$ mosquitto_sub -t &quot;test&quot;</span><br><span class="line">Error: Connection refused</span><br><span class="line">la@lll:~$ </span><br></pre></td></tr></table></div></figure>

<hr>
<p>ActiveMq服务器的部署：<br></p>
<ol>
<li>官方下载：<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://activemq.apache.org/">https://activemq.apache.org</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li>启动 ./activemq start</li>
<li>查看是否启动：<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep java |grep -v grep </span><br><span class="line">netstat -anp|grep 61616 </span><br><span class="line">lsof -i:61616</span><br></pre></td></tr></table></div></figure>
启动后的网址：<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="http://localhost:8161/">http://localhost:8161/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ol>
<p>有的时候启动失败了，日至会保存在：<code>apache-activemq-5.17.2/data/activemq.log</code>。报错信息里面如果讲的是端口占用，那我们可以进入<code>apache-activemq-5.17.2/conf/activemq.xml</code>修改端口号。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/01/22/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/">Linux基础知识学习</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-01-22</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-03-24</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="出现post-installation脚本返回错误的问题。">
          <a href="#出现post-installation脚本返回错误的问题。" class="heading-link"><i class="fas fa-link"></i></a><a href="#出现post-installation脚本返回错误的问题。" class="headerlink" title="出现post-installation脚本返回错误的问题。"></a>出现post-installation脚本返回错误的问题。</h1>
      <p>可以手动进入目录文件：/var/lib/dpkg/status 。打开这个文件（sudo gedit /var/lib/dpkg/status）然后找到出现包问题的那行，全部删除掉。然后保存文件。然后在执行sudo apt autoremove方法可以发现问题解决。</p>
<p><a href="%22%5B(5%E6%9D%A1%E6%B6%88%E6%81%AF">解决依赖</a> Ubuntu出现依赖关系问题 - 仍未被配置问题_Song的学习记录-CSDN博客_ubuntu依赖关系](<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://blog.csdn.net/s306205127/article/details/78546484)&quot;">https://blog.csdn.net/s306205127/article/details/78546484)&quot;</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>)</p>

        <h1 id="进行dpkg安装的时候如果出现缺少依赖包的报错，那么就执行代码来自动安装缺少的包">
          <a href="#进行dpkg安装的时候如果出现缺少依赖包的报错，那么就执行代码来自动安装缺少的包" class="heading-link"><i class="fas fa-link"></i></a><a href="#进行dpkg安装的时候如果出现缺少依赖包的报错，那么就执行代码来自动安装缺少的包" class="headerlink" title="进行dpkg安装的时候如果出现缺少依赖包的报错，那么就执行代码来自动安装缺少的包"></a>进行dpkg安装的时候如果出现缺少依赖包的报错，那么就执行代码来自动安装缺少的包</h1>
      <p>sudo apt-get -f install 。 并且执行完这个方法，系统会自动帮我们完成安装过程，不需要再次使用dpkg进行安装。</p>
<p>如果apt的版本在1.1以上 可以执行使用apt安装 .deb文件。</p>
<p>sudo apt install ./包</p>

        <h1 id="安装软件包">
          <a href="#安装软件包" class="heading-link"><i class="fas fa-link"></i></a><a href="#安装软件包" class="headerlink" title="安装软件包"></a>安装软件包</h1>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">下列软件包有为满足的依赖关系：</span><br><span class="line"> * ： 依赖：python3-apt 但是它将不会被安装</span><br><span class="line">E: 无法修正错误，因为您要求某些软件包保持现状，就是它们破坏了软件包间的依赖关系。</span><br></pre></td></tr></table></div></figure>

<p>这个原因是因为python3他需要依赖包libpython3-stdlib 3.6.5。但是在我安装python之前已经安装了他的高版本libpython3-stdlib 3.7.7。所以就没法安装了。这就是包依赖问题。不能用apt-get -f install 来解决了。</p>
<p>需要用aptitude：</p>
<p>首先下载aptitude：sudo apt-get install apitude</p>
<p>sudo aptitude -f install</p>
<p>[解决依赖包版本不统一导致的问题](“<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://www.jianshu.com/p/ce514e8738e1">Ubuntu解决依赖关系问题的正确姿势 - 简书 (jianshu.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>“)</p>

        <h1 id="安装Typora">
          <a href="#安装Typora" class="heading-link"><i class="fas fa-link"></i></a><a href="#安装Typora" class="headerlink" title="安装Typora"></a>安装Typora</h1>
      <ol>
<li><p>进入官网typora.io。下载他的二进制文件</p>
</li>
<li><p>执行命令：tar -xzvf Typora.tar.gz</p>
</li>
<li><p>创建桌面图标 touch Typora.desktop</p>
<p>填入内容：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Name=Typora</span><br><span class="line">GenericName=Editorubuntu / linux </span><br><span class="line">Comment=Typroa - a markdown editor</span><br><span class="line">Exec=&quot;Typora的绝对路径&quot; %U</span><br><span class="line">Icon=图标的绝对路径</span><br><span class="line">Terminal=false</span><br><span class="line">Categories=Markdown;ux</span><br><span class="line">StartupNotify=false</span><br><span class="line">Type=Application</span><br></pre></td></tr></table></div></figure></li>
<li><p>如果想在那个啥里面也可以看到他可以把Typora.desktop文件移动到 /usr/share/applications 里面。</p>
</li>
</ol>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/page/2/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/4/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/stun-logo.svg" alt="avatar"></div><p class="sidebar-ov-author__text">libertyYu</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/librityYu/" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="1169927533" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">96</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">27</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">18</div><div class="sidebar-ov-state-item__name">标签</div></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.4.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.2</span></div><script src="https://unpkg.com/mermaid@8.8.3/dist/mermaid.min.js"></script><var>me = require('mermaid')</var></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script></body></html>