<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="RecycledView四级缓存的生命周期        mAttachedScrap,他的数据随着一次layout从无到有再到无.  从无到有 -&gt;   执行layoutChildren时候,会执行detachAndScrapAttachViews()方法,当viewholder.flag!&#x3D;INVALID &amp;&amp; !viewHolde">
<meta property="og:type" content="article">
<meta property="og:title" content="Recycleview的自问自答">
<meta property="og:url" content="http://example.com/2023/02/01/Recycleview%E7%9A%84%E8%87%AA%E9%97%AE%E8%87%AA%E7%AD%94/index.html">
<meta property="og:site_name" content="Liberty&#39;s Blog">
<meta property="og:description" content="RecycledView四级缓存的生命周期        mAttachedScrap,他的数据随着一次layout从无到有再到无.  从无到有 -&gt;   执行layoutChildren时候,会执行detachAndScrapAttachViews()方法,当viewholder.flag!&#x3D;INVALID &amp;&amp; !viewHolde">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-02-01T05:05:04.000Z">
<meta property="article:modified_time" content="2023-04-26T06:05:40.457Z">
<meta property="article:author" content="Liberty">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary"><title>Recycleview的自问自答 | Liberty's Blog</title><link ref="canonical" href="http://example.com/2023/02/01/Recycleview%E7%9A%84%E8%87%AA%E9%97%AE%E8%87%AA%E7%AD%94/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: true,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/日记/"><span class="header-nav-menu-item__icon"><i class="fas fa-book"></i></span><span class="header-nav-menu-item__text">日记</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">Liberty's Blog</div><div class="header-banner-info__subtitle"></div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">Recycleview的自问自答</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-02-01</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2023-04-26</span></span></div></header><div class="post-body">
        <h1 id="RecycledView四级缓存的生命周期">
          <a href="#RecycledView四级缓存的生命周期" class="heading-link"><i class="fas fa-link"></i></a><a href="#RecycledView四级缓存的生命周期" class="headerlink" title="RecycledView四级缓存的生命周期"></a>RecycledView四级缓存的生命周期</h1>
      <ol>
<li><code>mAttachedScrap</code>,他的数据随着一次<code>layout</code>从无到有再到无.</li>
</ol>
<p><strong>从无到有 -&gt;</strong>  </p>
<p>执行<code>layoutChildren</code>时候,会执行<code>detachAndScrapAttachViews()</code>方法,当<code>viewholder.flag</code>!=<code>INVALID</code> &amp;&amp; <code>!viewHolder.isRemoved()</code> &amp;&amp; <code>!mRecyclerView.mAdapter.hasStableIds()</code>的时候,当前的<code>ViewHodler</code>就会被添加进入<code>mAttachedScrap</code></p>
<p><strong>从有到无 -&gt;</strong></p>
<p>在<code>layoutChunk</code>阶段,从<code>mAttachedScrap</code>拿到对应的<code>ViewHolder</code>后,执行<code>addView</code>操作完成后,当前<code>ViewHodler</code>就会从<code>mAttachedScrao</code>里面进行移除.</p>
<p>所以<code>mAttachedScrap</code>的值随着一次布局从存在到消失.</p>
<ol start="2">
<li><p><code>mCachedView</code>生命周期.在滑动的是动态添加和移除.然后在调用<code>notifyDataSetChanged</code>时候会被清空.</p>
</li>
<li><p><code>RecycledViewPool</code>生命周期.添加进去就会一直存在.</p>
</li>
</ol>
<hr>

        <h1 id="Recycleview获取ViewHolder顺序">
          <a href="#Recycleview获取ViewHolder顺序" class="heading-link"><i class="fas fa-link"></i></a><a href="#Recycleview获取ViewHolder顺序" class="headerlink" title="Recycleview获取ViewHolder顺序:"></a><code>Recycleview</code>获取<code>ViewHolder</code>顺序:</h1>
      <ol>
<li>如果当前<code>Recycleview.State.isPreLayout()==true</code>则先从<code>mChangedScrap</code>数组里面获取,然后会将获取到的<code>ViewHolder</code>的<code>Flag</code>赋值为<code>FLAG_RETURNED_FROM_SCRAP</code>.<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ViewHolder <span class="title">tryGetViewHolderForPositionByDeadline</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mState.isPreLayout())&#123;</span><br><span class="line">        holder = mChangedScrap.get(position);</span><br><span class="line">        holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li>从<code>mAttachedScrap</code>数组获取,还会将获取到的<code>ViewHolder</code>的<code>flag</code>赋值为<code>FLAG_RETURNED_FROM_SCRAP</code><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ViewHolder <span class="title">tryGetViewHolderForPositionByDeadline</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">    ----</span><br><span class="line">    holder = mAttachedScrap.get(position)</span><br><span class="line">    holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP);</span><br><span class="line">    ----</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li>从<code>ChildHelper.mHiddenViews</code>数组获取</li>
<li>从<code>mCachedViews</code>获取,获取完后会从<code>mCachedViews</code>里面移除当前对他的缓存<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ViewHolder <span class="title">tryGetViewHolderForPositionByDeadline</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">    ----</span><br><span class="line">    holder = mCachedViews.get(position);</span><br><span class="line">    ----</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li>从<code>mViewCacheExtenstion</code>获取,这个需要开发者自行实现</li>
<li>从<code>recycledViewPool</code>获取,需要注意,从这里获取的<code>viewHolder</code>会进行一个重置操作,重置内容如下:<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resetInternal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mFlags = <span class="number">0</span>;</span><br><span class="line">        mPosition = NO_POSITION;</span><br><span class="line">        mOldPosition = NO_POSITION;</span><br><span class="line">        mItemId = NO_ID;</span><br><span class="line">        mPreLayoutPosition = NO_POSITION;</span><br><span class="line">        mIsRecyclableCount = <span class="number">0</span>;</span><br><span class="line">        mShadowedHolder = <span class="keyword">null</span>;</span><br><span class="line">        mShadowingHolder = <span class="keyword">null</span>;</span><br><span class="line">        clearPayload();</span><br><span class="line">        mWasImportantForAccessibilityBeforeHidden = ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_AUTO;</span><br><span class="line">        mPendingAccessibilityState = PENDING_ACCESSIBILITY_STATE_NOT_SET;</span><br><span class="line">        clearNestedRecyclerViewIfNotNested(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
所有的缓存里面,只有从<code>RecycledViewPool</code>里面获取的<code>ViewHolder</code>需要重新执行<code>bind</code>操作.<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ViewHolder tryGetViewHolderForPositionByDeadline(int position)&#123;</span><br><span class="line">    ----</span><br><span class="line">    holder = getRecycledViewPool.getRecycledView(type);</span><br><span class="line">    holder.resetInternal();</span><br><span class="line">    ----</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li>缓存里面还没拿到<code>ViewHolder</code>的话就去执行<code>createViewHolder</code>操作.</li>
</ol>
<hr>

        <h1 id="Recycleview什么时候会执行bindViewHolder操作">
          <a href="#Recycleview什么时候会执行bindViewHolder操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#Recycleview什么时候会执行bindViewHolder操作" class="headerlink" title="Recycleview什么时候会执行bindViewHolder操作:"></a><code>Recycleview</code>什么时候会执行<code>bindViewHolder</code>操作:</h1>
      <p>在执行<code>bindViewHolder</code>方法前有个判断:</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!holder.isBound() || holder.needsUpdate() || holder.isInvalid())&#123;</span><br><span class="line">    bindViewHolder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p><code>holder.isBound() = true</code>是在执行过一次<code>bindViewHodler</code>后进行的赋值.在第一次布局的时候,所有的<code>ViewHolder</code>都会执行<code>bindViewHolder</code>操作.然后执行完<code>bindViewHodler</code>操作后,当前的<code>viewHodler</code>的<code>flag</code>会被赋值<code>FLAG_BOUND</code>.</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bindViewHolder</span><span class="params">(ViewHodler holder,<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">    holder.position = positon;</span><br><span class="line">    holder.setFlags(ViewHolder.FLAG_BOUND,</span><br><span class="line">            ViewHolder.FLAG_BOUND | ViewHolder.FLAG_UPDATE | ViewHolder.FLAG_INVALID</span><br><span class="line">                    | ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>所以:</p>
<ol>
<li>第一次布局的时候会执行<code>bindViewHolder</code></li>
<li>从<code>RecycledViewPool</code>里面获取到的<code>ViewHolder</code>会重新执行<code>bind</code>,因为<code>RecycledViewPool</code>厘面的<code>viewHodler</code>的<code>flag</code>会被重置掉.</li>
<li>调用<code>notify</code>方法标记了需要更新的<code>viewHodler</code>他们的<code>flag</code>会带有<code>FLAG_UPDATE</code>.所以会重新执行<code>bind</code>操作.</li>
</ol>
<hr>

        <h1 id="为什么执行notifyDataSetChaged-所有的ViewHodler会重新执行bind操作-而执行notifyItemChanged-不会导致全部的viewHolder执行bind操作">
          <a href="#为什么执行notifyDataSetChaged-所有的ViewHodler会重新执行bind操作-而执行notifyItemChanged-不会导致全部的viewHolder执行bind操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么执行notifyDataSetChaged-所有的ViewHodler会重新执行bind操作-而执行notifyItemChanged-不会导致全部的viewHolder执行bind操作" class="headerlink" title="为什么执行notifyDataSetChaged()所有的ViewHodler会重新执行bind操作,而执行notifyItemChanged()不会导致全部的viewHolder执行bind操作:"></a>为什么执行<code>notifyDataSetChaged()</code>所有的<code>ViewHodler</code>会重新执行<code>bind</code>操作,而执行<code>notifyItemChanged()</code>不会导致全部的<code>viewHolder</code>执行<code>bind操作</code>:</h1>
      <p>首先需要搞清楚哪些<code>ViewHolder</code>是需要执行<code>bind</code>操作的:</p>
<ol>
<li><code>flag</code>值没有<code>FLAG_BOUND</code>  </li>
<li><code>flag</code>值有<code>UPDATE</code>  </li>
<li><code>flag</code>值有<code>INVALID</code>  </li>
</ol>
<p>那哪些情况下<code>flag</code>会符合上面三种情况?</p>
<ol>
<li>从<code>RecycledViewPool</code>里获取到的<code>ViewHodler</code>,他们的<code>Flag</code>值都为0</li>
<li>调用了<code>notifyDataSetChanged</code>方法,导致在布局的时候,获取到的<code>ViewHodler</code>是从<code>RecycledViewPool</code>里面获取到的.</li>
<li>调用了<code>nofifyItemChanged</code>,他会将<code>flag</code>标记为<code>UPDATE</code></li>
</ol>
<p>所以上面这个问题就好回答了,因为调用<code>notifyDataSetChanged</code>会导致获取<code>viewHolder</code>的操作都从<code>RecycledViewPool</code>里面获取,所以所有的<code>viewHolder</code>都会重新执行<code>bind</code>操作.而调用<code>notifyItemChanged</code>方法,所有的<code>ViewHodler</code>都是从<code>mAttachedScrap</code>里面获取的,然后只有需要更新的<code>viewHodler</code>的<code>flag</code>等于<code>FLAG_UPDATE</code>.所以只有需要更新的才会执行<code>bind</code>操作.</p>
<hr>

        <h1 id="为什么调用notifyDataSetChanged更新视图的时候-会导致视图全部重新执行bind操作">
          <a href="#为什么调用notifyDataSetChanged更新视图的时候-会导致视图全部重新执行bind操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么调用notifyDataSetChanged更新视图的时候-会导致视图全部重新执行bind操作" class="headerlink" title="为什么调用notifyDataSetChanged更新视图的时候,会导致视图全部重新执行bind操作."></a>为什么调用<code>notifyDataSetChanged</code>更新视图的时候,会导致视图全部重新执行<code>bind</code>操作.</h1>
      <p>要探究这个问题就需要去看<code>detachAndScrapAttachdViews()</code>方法.这个方法是在<code>layoutChildren</code>阶段执行的.这个方法在初学阶段你是看不懂的,更不会用了, 现在我来讲明白.<br>这个方法做的事情就是<strong>分离视图</strong>和<strong>缓存已经存在的<code>viewHodler</code></strong>.  </p>
<p>分离视图有两种选择:  </p>
<ol>
<li><code>removeView</code></li>
<li><code>detachViewFromParent</code></li>
</ol>
<p>缓存<code>viewHodler</code>有四种方法选择:</p>
<ol>
<li>存进<code>mCachedViews</code></li>
<li>存进<code>recycledViewPool</code></li>
<li>存进<code>mAttachedScrap</code></li>
<li>存进<code>mChangedScrap</code></li>
</ol>
 <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">detachAndScrapAttachdViews</span><span class="params">(Recycler recycler, <span class="keyword">int</span> index, View view)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">final</span> ViewHolder viewHolder = getChildViewHolderInt(view);</span><br><span class="line">           <span class="keyword">if</span> (viewHolder.isInvalid() &amp;&amp; !viewHolder.isRemoved()</span><br><span class="line">                   &amp;&amp; !mRecyclerView.mAdapter.hasStableIds()) &#123;</span><br><span class="line">                   <span class="comment">//情况1</span></span><br><span class="line">               removeViewAt(index);</span><br><span class="line">               addViewHolderToRecycledViewPool(holder)</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 情况2</span></span><br><span class="line">               detachViewAt(index);</span><br><span class="line">              <span class="keyword">if</span>(flag == removed || falg == Invalid || !flag==update)&#123;</span><br><span class="line">                  mAttachedScrap.add(hodler)</span><br><span class="line">              &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  mChangedScrap.add(hodler)</span><br><span class="line">              &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></div></figure>
<p> 我们在调用<code>notifyDataSetChanged</code>的时候,他会将我们的所有的<code>viewHodler</code>的<code>flag</code>设置为<code>invalid 和 update</code>并且清空了<code>mCachedViews</code>缓存,就导致在方法<code>detachedAndScrapAttachViews</code>时候符合情况1,将当前的全部<code>ViewHodler</code>缓存进了<code>RecycledViewPool</code>里面.所以就导致执行更新时,会重新都走一遍<code>bind</code>操作.<br> 所以我们要少用<code>notifyDataSetChanged</code>方法,他在回收的时候执行的是<code>removeView</code>操作,是一个很重的操作,然后所有的ViewHodler也会被保存进<code>RecycledViewPool</code>里面,而不是<code>mRecycledScrap</code>里面,就导致还会重新走一遍<code>bind</code>操作,增加了页面更新的时间.</p>
<hr>

        <h1 id="Recycleview里面分割线的实现原理">
          <a href="#Recycleview里面分割线的实现原理" class="heading-link"><i class="fas fa-link"></i></a><a href="#Recycleview里面分割线的实现原理" class="headerlink" title="Recycleview里面分割线的实现原理"></a>Recycleview里面分割线的实现原理</h1>
      <p><code>Recycleview</code>的分割线是单独画上去的,在<code>draw</code>阶段画的,所以他的层次要高于<code>ViewHolder</code>,因为他是晚于<code>ViewHolder</code>绘制.  </p>
<p>看下测量阶段:</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Recycleview</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LayoutManager</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child,<span class="keyword">int</span> widthUsed,<span class="keyword">int</span> heightUsed)</span></span>&#123;</span><br><span class="line">         <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line"><span class="comment">//标记1</span></span><br><span class="line">            <span class="keyword">final</span> Rect insets = mRecyclerView.getItemDecorInsetsForChild(child);</span><br><span class="line">            widthUsed += insets.left + insets.right;</span><br><span class="line">            heightUsed += insets.top + insets.bottom;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> widthSpec = getChildMeasureSpec(getWidth(), getWidthMode(),</span><br><span class="line">                    getPaddingLeft() + getPaddingRight()</span><br><span class="line">                            + lp.leftMargin + lp.rightMargin + widthUsed, lp.width,</span><br><span class="line">                    canScrollHorizontally());</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> heightSpec = getChildMeasureSpec(getHeight(), getHeightMode(),</span><br><span class="line">                    getPaddingTop() + getPaddingBottom()</span><br><span class="line">                            + lp.topMargin + lp.bottomMargin + heightUsed, lp.height,</span><br><span class="line">                    canScrollVertically());</span><br><span class="line">            <span class="keyword">if</span> (shouldMeasureChild(child, widthSpec, heightSpec, lp)) &#123;</span><br><span class="line">                child.measure(widthSpec, heightSpec);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>在标记1的地方,可以看到去获取了我们分割线的大小.</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Rect <span class="title">getItemDecorInsetsForChild</span><span class="params">(View child)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">        <span class="keyword">if</span> (!lp.mInsetsDirty) &#123;</span><br><span class="line">            <span class="keyword">return</span> lp.mDecorInsets;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mState.isPreLayout() &amp;&amp; (lp.isItemChanged() || lp.isViewInvalid())) &#123;</span><br><span class="line">            <span class="keyword">return</span> lp.mDecorInsets;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Rect insets = lp.mDecorInsets;</span><br><span class="line">        insets.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> decorCount = mItemDecorations.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; decorCount; i++) &#123;</span><br><span class="line">            mTempRect.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">           <span class="comment">//标记2</span></span><br><span class="line">            mItemDecorations.get(i).getItemOffsets(mTempRect, child, <span class="keyword">this</span>, mState);</span><br><span class="line">            insets.left += mTempRect.left;</span><br><span class="line">            insets.top += mTempRect.top;</span><br><span class="line">            insets.right += mTempRect.right;</span><br><span class="line">            insets.bottom += mTempRect.bottom;</span><br><span class="line">        &#125;</span><br><span class="line">        lp.mInsetsDirty = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> insets;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>
<p>在标记2的位置可以看到调用了<code>ItemDirection</code>的<code>getItemOffsets</code>方法,去获取每个<code>viewHolder</code>对应的边距.所以自定义<code>ItemDirection</code>的时候,需要你重写<code>getItemOffsets</code>方法.设置完的值会被保存在<code>layoutParams.mDecorInsets</code>里面.</p>
<p>大小获取完成了.现在就是布局了.再来看下布局:</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearLayoutManager</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">layoutChunk</span><span class="params">()</span></span>&#123;</span><br><span class="line">        layoutDecoratedWidthMargins(view,l,t,r,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layoutDecoratedWithMargins</span><span class="params">(<span class="meta">@NonNull</span> View child, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">        <span class="keyword">final</span> Rect insets = lp.mDecorInsets;</span><br><span class="line">        child.layout(left + insets.left + lp.leftMargin, top + insets.top + lp.topMargin,</span><br><span class="line">                right - insets.right - lp.rightMargin,</span><br><span class="line">                bottom - insets.bottom - lp.bottomMargin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>可以看到通过<code>layoutParams</code>去获取了<code>mDecorInsets</code>值.这是我们在<code>measure</code>设置进去的.</p>
<p>综上所述,分析了<code>Recycleview</code>的分割线实现原理.</p>
<hr>

        <h1 id="recycleview获取ViewHolder的方法">
          <a href="#recycleview获取ViewHolder的方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#recycleview获取ViewHolder的方法" class="headerlink" title="recycleview获取ViewHolder的方法:"></a>recycleview获取ViewHolder的方法:</h1>
      <ol>
<li><code>Recycleview</code>的成员方法<code>findViewHolderForPosition(postion)</code></li>
<li><code>Recycleview</code>的成员方法<code>findViewHolderForLayoutPosition(position)</code></li>
<li><code>Recycleview</code>的成员方法<code>findViewHolderforAdapterPosition(position)</code></li>
<li><code>Recycleview</code>的成员方法<code>findViewHolderForItemId(id)</code></li>
</ol>
<p>区别:1 和 2 是一样子的. 2 和 3是不一样的.<br><code>findViewHolderForLayoutPosition</code>获取的是<code>holder.layoutPosition</code>值.<code>findViewHolderforAdapterPosition</code>获取的是<code>holder.position</code>值.<br>那现在问题来了,<code>ViewHolder</code>里的<code>position和mPreLayoutPosition</code>他们都表示位置信息,那有什么区别呢?<br>区别在,<code>mPreLayoutPosition</code>获取的是当前此刻<code>viewHolder</code>在的位置.而<code>position</code>代表这次<code>onLayout</code>结束后这个<code>viewholder</code>的位置.这个值会更准确.  </p>
<p>我们可以来看下源码:<br><strong>首先看<code>findViewHolderForLayoutPosition</code>:</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ViewHolder <span class="title">findViewHolderForLayoutPosition</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findViewHolderForPosition(position, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ViewHolder <span class="title">findViewHolderForPosition</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">boolean</span> checkNewPosition)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childCount = mChildHelper.getUnfilteredChildCount();</span><br><span class="line">        ViewHolder hidden = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> ViewHolder holder = getChildViewHolderInt(mChildHelper.getUnfilteredChildAt(i));</span><br><span class="line">            <span class="keyword">if</span> (holder != <span class="keyword">null</span> &amp;&amp; !holder.isRemoved()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (checkNewPosition) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (holder.mPosition != position) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (holder.getLayoutPosition() != position) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (mChildHelper.isHidden(holder.itemView)) &#123;</span><br><span class="line">                    hidden = holder;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> holder;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hidden;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>
<p>可以看到默认<code>checkNewPostion</code>传的就是<code>false</code>,表示不检查新位置,直接返回当前<code>mPreLayoutPosition</code>等于目标值的<code>viewHolder</code></p>
<p>再来看看<code>findViewHolderForAdapterPosition</code>:</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ViewHolder <span class="title">findViewHolderForAdapterPosition</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mDataSetHasChangedAfterLayout) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childCount = mChildHelper.getUnfilteredChildCount();</span><br><span class="line">        ViewHolder hidden = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> ViewHolder holder = getChildViewHolderInt(mChildHelper.getUnfilteredChildAt(i));</span><br><span class="line">            <span class="keyword">if</span> (holder != <span class="keyword">null</span> &amp;&amp; !holder.isRemoved()</span><br><span class="line">                    &amp;&amp; getAdapterPositionFor(holder) == position) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mChildHelper.isHidden(holder.itemView)) &#123;</span><br><span class="line">                    hidden = holder;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> holder;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hidden;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>
<p>可以看到当<code>mDataSetHasChangedAfterLayout</code>为<code>true</code>的时候会返回<code>null</code>,那什么时候这个值会为<code>true</code>呢,在<code>adapter</code>调用方法<code>notifyDataSetHasChanged</code>的时候,会赋值他为<code>true</code>.然后在看方法<code>getAdapterPositionfor(viewHolder)</code></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getAdapterPositionFor</span><span class="params">(ViewHolder viewHolder)</span> </span>&#123;</span><br><span class="line">    mAdapterHelper.applyPendingUpdatesToPosition(viewHolder.mPosition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">applyPendingUpdatesToPosition</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = mPendingUpdates.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        UpdateOp op = mPendingUpdates.get(i);</span><br><span class="line">        <span class="keyword">switch</span> (op.cmd) &#123;</span><br><span class="line">            <span class="keyword">case</span> UpdateOp.ADD:</span><br><span class="line">                <span class="keyword">if</span> (op.positionStart &lt;= position) &#123;</span><br><span class="line">                    position += op.itemCount;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> UpdateOp.REMOVE:</span><br><span class="line">                <span class="keyword">if</span> (op.positionStart &lt;= position) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> end = op.positionStart + op.itemCount;</span><br><span class="line">                    <span class="keyword">if</span> (end &gt; position) &#123;</span><br><span class="line">                        <span class="keyword">return</span> RecyclerView.NO_POSITION;</span><br><span class="line">                    &#125;</span><br><span class="line">                    position -= op.itemCount;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> UpdateOp.MOVE:</span><br><span class="line">                <span class="keyword">if</span> (op.positionStart == position) &#123;</span><br><span class="line">                    position = op.itemCount; <span class="comment">//position end</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (op.positionStart &lt; position) &#123;</span><br><span class="line">                        position -= <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (op.itemCount &lt;= position) &#123;</span><br><span class="line">                        position += <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> position;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>可以看到内部调用了方法<Code>applyPendingUpdatesToPosition翻译下:执行内部位置更新操作.里面涉及到了数组<code>mPendingUpdates</code>,这个数组在我们执行<code>notifyItemInserted  notifyItemMoved  notifyItemRangeChanged</code>方法的时候会生成操作对象然后存入到<Code>mPendingUpdates数组里面….然后在我们获取<code>viewHolder.position</code>的时候,这时候会考虑到在执行更新操作的时候是否影响到了当前我们的<code>viewHolder</code>如果影响到了,就根具具体的操作去获取这次操作结束后的位置.  这就印证了我上面讲的,<code>findViewHodlerforAdapterPostion</code>获取的位置是这次<coed>onLayout结束后的位置.<code>findViewHolderForLayoutPosition</code>获取的是当前<code>viewHolder</code>的位置.</coed></Code></Code></p>

        <h1 id="分析下Recycleview的dispatchLayout1">
          <a href="#分析下Recycleview的dispatchLayout1" class="heading-link"><i class="fas fa-link"></i></a><a href="#分析下Recycleview的dispatchLayout1" class="headerlink" title="分析下Recycleview的dispatchLayout1"></a>分析下Recycleview的dispatchLayout1</h1>
      <p>关于<code>Recycleview</code>的布局分为三个阶段:<code>dispatchLayout1()  dispatchLayout2  dispatchLayout3()</code>.先分析下<code>dispatchLayout1()</code>:  </p>
<ul>
<li>看下<code>processAdapterUpdatesAndSetAnimationFlags</code>方法:<br>这个方法会遍历数组<code>mPendingUpdates</code>数组,(这个数组存的是我们在执行<code>nofityItemInserted</code>等更新方法时候的操作),比如我们执行了一个插入更新操作,那么在<code>dispatchLayout1()</code>阶段遍历这个数组的目的就是更新所有因为这个插入操作而导致的位置更新的<code>viewHolder</code><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postponeAndUpdateViewHolders</span><span class="params">(UpdateOp op)</span> </span>&#123;</span><br><span class="line">        mPostponedList.add(op);</span><br><span class="line">        <span class="keyword">switch</span> (op.cmd) &#123;</span><br><span class="line">            <span class="keyword">case</span> UpdateOp.ADD:</span><br><span class="line">                mCallback.offsetPositionsForAdd(op.positionStart, op.itemCount);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> UpdateOp.MOVE:</span><br><span class="line">                mCallback.offsetPositionsForMove(op.positionStart, op.itemCount);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> UpdateOp.REMOVE:</span><br><span class="line">                mCallback.offsetPositionsForRemovingLaidOutOrNewView(op.positionStart,</span><br><span class="line">                        op.itemCount);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> UpdateOp.UPDATE:</span><br><span class="line">                mCallback.markViewHoldersUpdated(op.positionStart, op.itemCount, op.payload);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unknown update op type for &quot;</span> + op);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offsetPositionsForAdd</span><span class="params">(<span class="keyword">int</span> positionStart, <span class="keyword">int</span> itemCount)</span> </span>&#123;</span><br><span class="line">    offsetPositionRecordsForInsert(positionStart, itemCount);</span><br><span class="line">    mItemsAddedOrRemoved = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">offsetPositionRecordsForInsert</span><span class="params">(<span class="keyword">int</span> positionStart, <span class="keyword">int</span> itemCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childCount = mChildHelper.getUnfilteredChildCount();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> ViewHolder holder = getChildViewHolderInt(mChildHelper.getUnfilteredChildAt(i));</span><br><span class="line">            <span class="keyword">if</span> (holder != <span class="keyword">null</span> &amp;&amp; !holder.shouldIgnore() &amp;&amp; holder.mPosition &gt;= positionStart) &#123;</span><br><span class="line">               <span class="comment">//去更新viewHolder的position值</span></span><br><span class="line">               holder.offsetPosition(itemCount, <span class="keyword">false</span>);</span><br><span class="line">                mState.mStructureChanged = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mRecycler.offsetPositionRecordsForInsert(positionStart, itemCount);</span><br><span class="line">        requestLayout();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
<ul>
<li><p>看下方法<code>findMinMaxChildLayoutPositons(int info)</code>:<br>在<code>Recycleview</code>里有一个成员属性<code>int[] mMinMaxLayoutPosition</code>这个属性保存了<code>Recycleview</code>在屏幕上可以显示的最小和最大的<code>item</code>值.帮助<code>Recycleview</code>在滑动的时候确定要显示哪些<code>item</code>,以提高滑动的流畅性.这个值在<code>dispatchLayout1</code>阶段会去修改:</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findMinMaxChildLayoutPositions</span><span class="params">(<span class="keyword">int</span>[] into)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = mChildHelper.getChildCount();</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        into[<span class="number">0</span>] = NO_POSITION;</span><br><span class="line">        into[<span class="number">1</span>] = NO_POSITION;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> minPositionPreLayout = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> maxPositionPreLayout = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        <span class="keyword">final</span> ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));</span><br><span class="line">        <span class="keyword">if</span> (holder.shouldIgnore()) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> pos = holder.getLayoutPosition();</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; minPositionPreLayout) &#123;</span><br><span class="line">            minPositionPreLayout = pos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pos &gt; maxPositionPreLayout) &#123;</span><br><span class="line">            maxPositionPreLayout = pos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    into[<span class="number">0</span>] = minPositionPreLayout;</span><br><span class="line">    into[<span class="number">1</span>] = maxPositionPreLayout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>可以看到遍历了当前屏幕上的所有孩子,找到他们的最小值和最大值.</p>
</li>
<li><p>继续看<code>dispatchLayout1</code>方法,现在看的是<code>Recycleview</code>如何标记哪些是需要执行动画操作的<code>view</code>.</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Recycleview</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dispatchLayout1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ***</span><br><span class="line">        <span class="keyword">if</span>(mState.mRunSimpleAnimatioms)&#123;</span><br><span class="line">        <span class="comment">//情况1</span></span><br><span class="line">            <span class="keyword">int</span> count = mChildHelper.getChildCount();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i)&#123;</span><br><span class="line">                ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));</span><br><span class="line">                ***</span><br><span class="line">                ItemHolderInfo animationInfo = mItemAnimator.recordPreLayoutInformation(mState,holder,flag,holder.getImodifiedPayloads());</span><br><span class="line">                mViewInfoStore.addToPreLayout(holder,animationInfo);</span><br><span class="line">                ***</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mState.mRunPredictiveAnimations)&#123;</span><br><span class="line">            <span class="comment">//情况2</span></span><br><span class="line">            saveOldPositions();</span><br><span class="line">            mLayout.onLayoutChildren(mRecycler,mState);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mChildHelper.getChildCount(); ++i)&#123;</span><br><span class="line">                View child = mChildHelper.getChildAt(i);</span><br><span class="line">                ViewHolder viewHolder.getChildViewHolderInt(child);</span><br><span class="line">            </span><br><span class="line"> <span class="comment">//在刚才的预布局里面没找到这个viewholder说明这是新建的viewholder,是需要执行动画的viewholder</span></span><br><span class="line">                <span class="keyword">if</span>(!mViewInfoStore.isInPreLayout(viewHolder))&#123;</span><br><span class="line">                mViewInfoStore.addToAppearedInPreLayoutHolders(viewHolder,animationInfo);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        ***</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>首先先看<strong>情况1:</strong>,他遍历了当前页面上的所有孩子,然后给每个<code>viewHolder</code>创建了<code>ItemHolderInfo</code>对象,并且保存在了<code>viewInfoStore</code>的<code>mLayoutHolderMap</code>里面,键名是<code>holder</code>键值是<code>InfoRecord</code>,这个时候每个<code>InfoRecord</code>的<code>flag</code>等于<strong>FLAG_PRE</strong>(从名字也可以看出是预布局的意思)</p>
</li>
</ul>
<p>再看<strong>情况2</strong>,他会去执行<code>layout.onLayoutChildren</code>进行一次布局,然后对比<strong>情况1</strong>看看多了哪些<code>ViewHolder</code>,这些多出来的<code>viewHolder</code>会被添加到<code>ViewInfoStore</code>里面然后<code>flag</code>会被赋值为<strong>FLAG_APPEAR</strong></p>
<p>到这里<code>dispatchLayout1</code>就分析完成了,他干了五件大事.</p>
<ul>
<li><p>第一件大事:<br>执行<code>processAdapterUpdatesAndSetAnimationFlags()</code>方法,遍历<code>mPendingUpdates</code>数组,修改页面上所有<code>viewHolder</code>的<code>position</code>数据,是增是减.然后给是否执行动画标志位进行赋值.</p>
</li>
<li><p>第二件大事:<br>给成员属性<code>mMinMaxLayoutPosition</code>赋值,找到目前显示的最大和最小<code>position</code>值</p>
</li>
<li><p>第三件大事:<br>将当前页面的所有<code>viewHolder</code>添加进了<code>viewInfoStore</code>里面然后设置<code>flag</code>等于<strong>FLAG_PRE</strong></p>
</li>
<li><p>第四件大事调用<code>layoutManager.onLayoutChildren()</code>,进去一次布局</p>
</li>
<li><p>第五件大事,遍历页面所有孩子,对比第三件大事里面的<code>mViewInfoStore</code>没有的<code>viewHolder</code>,然后将没有的<code>viewHodler</code>添加到<code>viewInfoStore</code>里面.并且设置<code>flag</code>等于<strong>FLAG_APPEAR</strong></p>
</li>
</ul>

        <h1 id="分析下Recycleview的dispatchLayoutSetp2">
          <a href="#分析下Recycleview的dispatchLayoutSetp2" class="heading-link"><i class="fas fa-link"></i></a><a href="#分析下Recycleview的dispatchLayoutSetp2" class="headerlink" title="分析下Recycleview的dispatchLayoutSetp2()"></a>分析下Recycleview的dispatchLayoutSetp2()</h1>
      
        <h1 id="Recycleview中AnchorInfo的作用">
          <a href="#Recycleview中AnchorInfo的作用" class="heading-link"><i class="fas fa-link"></i></a><a href="#Recycleview中AnchorInfo的作用" class="headerlink" title="Recycleview中AnchorInfo的作用"></a>Recycleview中AnchorInfo的作用</h1>
      <p><code>AnchorInfo</code>用于记录<code>Recycleview</code>的滚动状态,</p>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://example.com/tags/Android/">Android</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2023/02/01/%E4%B8%8B%E8%BD%BD%E7%BC%96%E8%AF%91%E6%9F%A5%E7%9C%8BAndroid12%E6%BA%90%E7%A0%81/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">下载编译查看Android12源码</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2023/02/01/%E5%85%B3%E4%BA%8EAdapter%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E7%9A%84%E5%88%86%E6%9E%90/"><span class="paginator-prev__text">关于Adapter进行数据更新的分析</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#RecycledView%E5%9B%9B%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.</span> <span class="toc-text">
          RecycledView四级缓存的生命周期</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Recycleview%E8%8E%B7%E5%8F%96ViewHolder%E9%A1%BA%E5%BA%8F"><span class="toc-number">2.</span> <span class="toc-text">
          Recycleview获取ViewHolder顺序:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Recycleview%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E6%89%A7%E8%A1%8CbindViewHolder%E6%93%8D%E4%BD%9C"><span class="toc-number">3.</span> <span class="toc-text">
          Recycleview什么时候会执行bindViewHolder操作:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%89%A7%E8%A1%8CnotifyDataSetChaged-%E6%89%80%E6%9C%89%E7%9A%84ViewHodler%E4%BC%9A%E9%87%8D%E6%96%B0%E6%89%A7%E8%A1%8Cbind%E6%93%8D%E4%BD%9C-%E8%80%8C%E6%89%A7%E8%A1%8CnotifyItemChanged-%E4%B8%8D%E4%BC%9A%E5%AF%BC%E8%87%B4%E5%85%A8%E9%83%A8%E7%9A%84viewHolder%E6%89%A7%E8%A1%8Cbind%E6%93%8D%E4%BD%9C"><span class="toc-number">4.</span> <span class="toc-text">
          为什么执行notifyDataSetChaged()所有的ViewHodler会重新执行bind操作,而执行notifyItemChanged()不会导致全部的viewHolder执行bind操作:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B0%83%E7%94%A8notifyDataSetChanged%E6%9B%B4%E6%96%B0%E8%A7%86%E5%9B%BE%E7%9A%84%E6%97%B6%E5%80%99-%E4%BC%9A%E5%AF%BC%E8%87%B4%E8%A7%86%E5%9B%BE%E5%85%A8%E9%83%A8%E9%87%8D%E6%96%B0%E6%89%A7%E8%A1%8Cbind%E6%93%8D%E4%BD%9C"><span class="toc-number">5.</span> <span class="toc-text">
          为什么调用notifyDataSetChanged更新视图的时候,会导致视图全部重新执行bind操作.</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Recycleview%E9%87%8C%E9%9D%A2%E5%88%86%E5%89%B2%E7%BA%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text">
          Recycleview里面分割线的实现原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#recycleview%E8%8E%B7%E5%8F%96ViewHolder%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">7.</span> <span class="toc-text">
          recycleview获取ViewHolder的方法:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E4%B8%8BRecycleview%E7%9A%84dispatchLayout1"><span class="toc-number">8.</span> <span class="toc-text">
          分析下Recycleview的dispatchLayout1</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E4%B8%8BRecycleview%E7%9A%84dispatchLayoutSetp2"><span class="toc-number">9.</span> <span class="toc-text">
          分析下Recycleview的dispatchLayoutSetp2()</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Recycleview%E4%B8%ADAnchorInfo%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">10.</span> <span class="toc-text">
          Recycleview中AnchorInfo的作用</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/stun-logo.svg" alt="avatar"></div><p class="sidebar-ov-author__text">libertyYu</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/librityYu/" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="1169927533" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">100</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">27</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">18</div><div class="sidebar-ov-state-item__name">标签</div></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.4.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.2</span></div><script src="https://unpkg.com/mermaid@8.8.3/dist/mermaid.min.js"></script><var>me = require('mermaid')</var></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script></body></html>